[{"content":" 我，无畏并发。 《BanG Dream! Ave Mujica》（大嘘）\n一些基本的讨论 锁应当存放在大家共用的内存空间，总之不应该是栈。 一个好的锁应该提供正确的互斥、保障线程公平、性能优秀。 一些失败的想法 关中断：这很容易被滥用，导致系统接收不到中断信息；不适用于多处理器系统。 Peterson 算法：必须假设访存的原子性，但这一点现代硬件早就打破了。 int flag[2]; int turn; void init() { flag[0] = flag[1] = 0; turn = 0; } void lock() { flag[self] = 1; // 竖起自己的旗子 turn = 1 - self; // 让 turn 等于对面 // 我们假设对面此时也执行了这两句，turn 此时等于 self while((flag[1 - self] == 1) \u0026amp;\u0026amp; (turn == 1 - self)) ; // 因为对面改变了turn，那我们先执行了，对面先等着 // 先修改 turn 的才能跳出这个 while，也就是手快有手慢无 } void unlock() { flag[self] = 0; } test-and-set 这种想法基于自旋锁（也就是只通过一个 flag 区分是否上锁），但是不依赖硬件显然不行，因为更精妙的 Peterson 都行不通。 x86 提供了与以下 C 代码类似的原子指令，硬件保证这个过程的原子性： // not code, but hardware implemented atomic test-and-set operation int TEST_AND_SET(int *old_ptr, int new) { int old = *old_ptr; *old_ptr = new; return old; } // 也就是把值改成新的，返回旧值 这样我们终于能够设计年轻人的第一把锁了：\n// this is C code!!! ","permalink":"http://localhost:4449/posts/os6-2/","summary":"作为无畏并发的基本手段，有必要复习一下设计锁的方法。","title":"操作系统复习·锁"},{"content":" 学而不思则罔，思而不学则殆。\n我们主要参考 sploitfun 先生的 Understanding glibc malloc 一文，对 malloc 的实现进行认真的学习和分析，最后形成了几张图解，比较全面地概括了相关的数据结构和算法。\n","permalink":"http://localhost:4449/posts/os6-1/","summary":"无论是操作系统内部还是应用程序，无论是单核 CPU 还是多核 CPU，堆分配都是操作系统实现和改良的核心话题之一。","title":"操作系统复习·堆分配"},{"content":"开发操作系统是我从小到大的梦想。但在追逐这个梦想的道路上我走了不少的弯路。\n初中的时候，我因为写 VBS 脚本装 B 认识了一位很好的朋友。我们一起讨论和学习 VBS，后来是 HTML，再后来是 VB 和 C#。那时候的我们相信，写一个操作系统是全天下最牛逼的事情。但就这点本事怎么可能写操作系统呢？我选择了用 PPT 来 “设计” “操作系统”，搞出一个 “Windows 13” 来。我的朋友选择用 C# 来模拟 Windows 的外观和基本功能，这样就看起来像是一个操作系统了。在这个 PPT 里，我通过 PowerPoint 内置的 VBA 写了一个记事本功能的“Word 2019”，那是我写的第一个程序。\n图 1 我用 PPT “设计” 的 “Windows 13.5” （微软请原谅我糟糕的美术知识）\n图 2 在另一个朋友制作的“手机”上搭载 “Windows 13 Phone”，那时的我可以很快画出 Win10 的 Hero 壁纸\n图 3 “也许 N 年后，Windows 13 系列会有后续，但那时，也许就不再是 PPT 了”\n高中的时候，我仍然在有限的空闲时间内继续空想一个操作系统。一方面，在闲暇时间，手边又没有电脑，我会手绘一些想到的“产品设计”；另一方面，我了解到有《30天自制操作系统》这本书，还在网上找了一些很有意思的教程，打算在有空闲时间时大干一场。\n图 4 我使用汇编语言写了第一个裸机应用程序 “Hello World”\n图 5 我那时还在着迷于所谓的“产品设计”\n可惜的是，那时候的空闲时间实在太少，我还把大部分时间用来开发一个在班级白板上使用的教学助手。等到有时间实践网上找到的操作系统教程时，却被汇编语言的难度和连接国际互联网的问题（那时不配置 apt 源在国内是用不成 apt 的。对于一个使用 Windows 很多年的爱好者，我在刚开始并没有找到学习 Ubuntu 的合理路径，被大量不熟悉的细节给围殴了。而且没有 Google 很多问题也没法完全搞清楚。）困扰了很久，最后还是放弃了。对那时的我，访问 Github 都得靠运气——据说早上九点是个好的时间。\n再后来，我成功得偿所愿进入计算机系学习。和操作系统相关的第一次尝试是数电实验课程。我那时仍然空想在我设计的 rv32ui 指令集的用 FPGA 模拟的 CPU 上运行自己写的操作系统——可是没有特权指令集，这怎么可能呢？最后，我仍然只实现了一个简陋的裸机终端。不过因为以往的这些执念，我没有组小组，而是一个人完成了从 CPU 设计到终端开发的全部工作——其实应该去 Github 找找裸机终端的代码的，那时候还是太年轻了。\n图 6 minTerminal 的架构图。那时的我很骄傲独立完成了这个项目\n现在的我，学习完了操作系统课程，认识到自己以前幼稚的探索确实错过了很多学习知识、实现梦想的机会。但蓦然回首，我发现我已经可以学习一个优秀的内核实现的全部代码了，我有信心掌握全部的细节。而且，还有《Operating Systems: Three Easy Pieces》这样优秀的教材。这比自己碰壁，在知乎上找“操作系统教程”有意义的多。\n好了，说了这么多废话，最后还是希望自己能坚持下来吧。\n","permalink":"http://localhost:4449/posts/os6-0/","summary":"本节内容和技术无关，纯属瞎唠叨。","title":"操作系统复习·前言"},{"content":"项目地址（配有使用方法）：https://github.com/HazeMa0/fly-hadoop2-workflow\n作为博客，还是整理一下这个过程中的困难吧。\n1 网络问题很烦人 首先，事实是：2024 年，中国大陆的主要高校和云服务商都关闭了 Docker Hub 的镜像源。但是百度仍有大量的帖子在建议更换镜像源以改善对 Docker Hub 的访问。\n我在我的 Windows 环境部署了代理。WSL2 理应继承代理设置。但是神奇的事情发生了：WSL2 我们可以顺利地 docker build，Windows 却不行。\n然后，我们做了以下事情试图让 Dockerfile 的 from 指令正常工作：\n设置 HTTP_PROXY 和 HTTPS_PROXY 环境变量； 注意！\nHTTPS_PROXY 对应的仍然是 http://localhost:1234，而不是 https！我是在发现环境变量使我的 VSCode 无法正常工作时才发现这个问题的；\n配置 Docker Engine 的配置文件： \u0026#34;proxies\u0026#34;: { \u0026#34;default\u0026#34;: { \u0026#34;httpProxy\u0026#34;: \u0026#34;http://127.0.0.1:9870\u0026#34;, \u0026#34;httpsProxy\u0026#34;: \u0026#34;http://127.0.0.1:9870\u0026#34;, \u0026#34;noProxy\u0026#34;: \u0026#34;localhost,127.0.0.1\u0026#34; } } 修改 ~/.docker/config.json（最后又删掉了） 在我没发现我把 HTTPS_PROXY 写成 https://\u0026hellip; 时，这三个修改都不起作用。然后，在一次神秘的 docker pull ... 后，突然就好起来了，我至今也没搞清楚到底是怎么回事。\n我们认识到，ping 命令走的是 ICMP 协议，对测试 http/socks5 的代理没有意义。 2 对 Docker 和 Dev Container 的错误理解 刚开始，我们在使用 Docker 运行和使用 Dev Container 作为开发环境上犹豫和摇摆了很长时间。我问了 AI 下面这一大段文字，可见我当时的烦躁。\n我现在陷入了一些混乱，需要你来拯救我。要写代码，首先要有开发环境。一般来说，这意味着编译器和解释器以及外部库和系统库的版本，还有代码构建工具的版本。这些东西在不同的开发项目中很容易冲突。然后我们运行起来了程序。然后希望交给测试测试。我没有在公司工作过，我不知道测试测试时需不需要源代码，还是只拿最终可执行程序进行测试。如果需要，那他也需要开发环境。然后经过修改，最后交付用户。用户不同软件之间的运行环境也可能冲突，一般来说，运行环境应该是开发环境的一个子集。容器要怎么终结这一系列混乱？\n好了，现在产生了问题。首先开发者要搭建一个叫做开发环境的玩意。把编译器/解释器/代码生成程序/外部库/系统库封装在容器里面是很好，问题是本地运行的IDE怎么和这些容器里面的玩意交互，从而支持语法高亮和其他功能呢？其次，我说了，运行环境往往是开发环境的子集，编译器对运行环境毫无必要。难道容器通过纵容这些冗余来换取分发效率吗？还有，为什么现实中面向普通用户的应用没有一个用docker分发呢？\n产生这些困惑的 Docker 相关问题是：\n以为代码的依赖都在容器里面，不希望手动把依赖拷到物理机恶心自己。虽然我们确实可以在容器里面援引相关的 jar，但更方便的方法是直接在本地通过 Maven 从中心仓库部署合适的依赖用于测试。 不了解容器挂载技术，以为我们必须手动把 jar 文件拷贝到容器测试。 不了解本地测试 Hadoop，以为所有类型的测试必须使用 hadoop jar 命令执行。实际上我们甚至可以不启动容器进行本地测试，完全本地开发。 区分不了镜像和容器。镜像是死的初始化状态，容器是基于镜像的可工作的实体。Dockerfile 产生镜像。 过早把自己摆到用户角度，认为开发环境对运行环境是冗余的（冗余了你改改 Dockerfile 不就行了吗，对刚开始的我来说改这玩意很困难，现在完全不是了） Dev Container 相关问题是：\n神圣化 Dev Container，以为其不会往容器里面部署 IDE 后端，从而产生了一系列矛盾； 以为 Dev Container 不能配置容器开放的端口。同时认识到，不能修改一个已经打开的容器的端口映射，这是为了简化容器运行状态故意为之的设计。 Dev Container 指定 entrypoint 不是在 postCreateCommand，也不是在 Dockerfile，只有通过 runArgs 指定才是正确的。 不知道为什么，让 Dev Container 执行我的脚本时不能正确识别 echo 的 -e 参数，而是将其作为文本打印。最后我们换用了 printf 命令。 一些 linux 知识 Hadoop 环境初始化脚本需要 ssh 连接，就会产生下面这种需要手动确认的麻烦问题： yes：The authenticity of host \u0026#39;localhost (::1)\u0026#39; can\u0026#39;t be established. ECDSA key fingerprint is SHA256:**********.\rAre you sure you want to continue connecting (yes/no)? 我们希望初始化脚本作为 Docker 的 1 号进程，当然不希望这种需要手工确认的东西出现。我们最终使用以下脚本解决：\ntouch ~/.ssh/config printf \u0026#34;Host *\\n\\tStrictHostKeyChecking no\\n\\tUserKnownHostsFile /dev/null\\n\u0026#34; \u0026gt; ~/.ssh/config 该死的 \\r\\n 在 Windows，git 默认会把 \\n 替换成 \\r\\n。这最后导致我的脚本 push 再 clone 后竟然无法运行了。最后一行命令解决问题： git config --global core.autocrlf false 有趣的事实：JDK 1.x == JDK x 2. 该死的讲义问题 讲义给出的一些命令根本是错误的。\n讲义没有细说应该怎么修改 Hadoop 的若干 xml，百度也在画蛇添足。只有官方文档才是可靠的。\n讲义没告诉我 start-all.sh 的正确位置，让我无法正确配置 PATH。\n鸣谢 感谢 DeepSeek 和 ChatGPT 耐心地听我抱怨和提出问题。没有任何一个人类受得了这么多怨气和不满。\n感谢官方的 Hadoop 安装教程。\n感谢 Google。珍爱生命，拒绝百度。\n","permalink":"http://localhost:4449/posts/fly-hadoop2-workflow/","summary":"项目地址：https://github.com/HazeMa0/fly-hadoop2-workflow。借助 Docker 和 Dev Container，舒适地开发老旧框架的程序。本文阐述了这个项目中遇到的困难。","title":"fly-hadoop2-workflow：让编写 hadoop 2.7 应用的效率飞起来"},{"content":" 相关软件（不限版本）\nnautilus 刚装好 Ubuntu，我们在文件管理器的右键菜单里面找不到新建文件的选项，这确实很让人匪夷所思。\n实际上，我们只需要在 ~/Templates 新建一个模板就好。\n$ cd ~/Templates $ touch `TXT.txt` $ touch `Markdown.md` 当然这个方案并不完美，就是并没有在新建文件后自动处于重命名状态的功能。\n","permalink":"http://localhost:4449/posts/nautilus-new-file/","summary":"为 nautilus 添加新建选项的菜单并不困难。因为 ~/Templates 就是专门为之服务的。","title":"如何为 nautilus 右键菜单添加新建文件选项"},{"content":" 相关软件版本\nUbuntu 22.04 及以上 nautilus 是 GNOME 桌面环境默认的 GUI 文件管理器。\n本来其实没想到这样一个简单的任务会引起一些麻烦。把我处理这个麻烦的过程记下来吧。\n首先，我们百度搜索这个问题，从一些相当新的帖子获得的解决方案是安装 nautilus-actions。但意外的是，在 Ubuntu 22.04 中，这个包被移除了。\n我们转战谷歌，找到了这篇帖子，告诉我们这个软件因为缺少更新已经被上游的 gnome 存档了。我们也并不想使用已经被废弃的软件，那就去找替代方案吧——我相信不可能没有提供。\n意外发现：gnome 原来用 gitlab 管理项目，有趣。\n翻译者没有兴趣维护这个软件：\u0026ldquo;Sorry, but if there\u0026rsquo;s no contributions for several years, we\u0026rsquo;re not going to keep it active. It wastes the efforts of our translators. Feel free to fork and maintain it somewhere else if you like (it\u0026rsquo;s open source, after all).\u0026rdquo;\n另一篇帖子 指出了两个替代方案：一个是我在以前使用过的 Nautilus Scripts，最终效果是在右键菜单里面显示一个 Scripts 子菜单，里面有我们写好的脚本作为选项。这种方法不够优雅，我们希望显示在主右键菜单里面；另一个是 nautilus-python，出于对 python 的好感我们最终选择这个方案。\n问题又来了，在 Ubuntu 安装 nautilus-python，也没有这个包。经过检查，一篇帖子 指出其在 Ubuntu 源的名称是 python3-nautilus，这可能是因为一些误解产生的问题。\n现在我们学习写 python 代码来实现 nautilus-python 的扩展。参考资源：官方示例、linuxconfig.org 的教程。我们将写好的 python 文件保存到 ~/.local/share/nautilus-python/extensions/ 即可，然后重启 nautilus 即可。\n先看下面的示例，其为 VSCode 打开文件夹和文件提供了右键菜单（使用命令 wget -qO- https://raw.githubusercontent.com/harry-cpp/code-nautilus/master/install.sh | bash 以快速安装，我对代码做了一些简化，原本的源代码请参考相应的 GitHub 仓库）：\nfrom gi.repository import Nautilus, GObject from subprocess import call import os class VSCodeExtension(GObject.GObject, Nautilus.MenuProvider): # python 支持多重继承 def launch_vscode(self, menu, files): # 参数是 self, menu, files，注意不要修改 safepaths = \u0026#39;\u0026#39; args = \u0026#39;\u0026#39; for file in files: filepath = file.get_location().get_path() safepaths += \u0026#39;\u0026#34;\u0026#39; + filepath + \u0026#39;\u0026#34; \u0026#39; if os.path.isdir(filepath) and os.path.exists(filepath): args = \u0026#39;--new-window \u0026#39; call(\u0026#39;code \u0026#39; + args + safepaths + \u0026#39;\u0026amp;\u0026#39;, shell=True) def get_file_items(self, *args): # 右键文件/文件夹时对应的方法 files = args[-1] item = Nautilus.MenuItem( name=\u0026#39;VSCodeOpen\u0026#39;, label=\u0026#39;Open in Code\u0026#39;, tip=\u0026#39;Opens the selected files with VSCode\u0026#39; ) item.connect(\u0026#39;activate\u0026#39;, self.launch_vscode, files) return [item] def get_background_items(self, *args): # 右键空白位置时的方法 file_ = args[-1] item = Nautilus.MenuItem( name=\u0026#39;VSCodeOpenBackground\u0026#39;, label=\u0026#39;Open in Code\u0026#39;, tip=\u0026#39;Opens the current directory in VSCode\u0026#39; ) item.connect(\u0026#39;activate\u0026#39;, self.launch_vscode, [file_]) return [item] 上面的 python 代码足够直观了。get_backgroud_items 和 get_file_items 返回一个菜单数组，而菜单如何创建和与具体的操作方法链接上面的示例已经足够说明。\n","permalink":"http://localhost:4449/posts/nautilus-right-click/","summary":"nautilus 是 GNOME 桌面环境默认的 GUI 文件管理器。本文介绍如何为 nautilus 添加自定义的右键菜单项。","title":"如何为 nautilus 配置右键菜单"},{"content":"","permalink":"http://localhost:4449/tags/","summary":"tags","title":"标签"},{"content":" 我，无畏并发。 《BanG Dream! Ave Mujica》（大嘘）\n一些基本的讨论 锁应当存放在大家共用的内存空间，总之不应该是栈。 一个好的锁应该提供正确的互斥、保障线程公平、性能优秀。 一些失败的想法 关中断：这很容易被滥用，导致系统接收不到中断信息；不适用于多处理器系统。 Peterson 算法：必须假设访存的原子性，但这一点现代硬件早就打破了。 int flag[2]; int turn; void init() { flag[0] = flag[1] = 0; turn = 0; } void lock() { flag[self] = 1; // 竖起自己的旗子 turn = 1 - self; // 让 turn 等于对面 // 我们假设对面此时也执行了这两句，turn 此时等于 self while((flag[1 - self] == 1) \u0026amp;\u0026amp; (turn == 1 - self)) ; // 因为对面改变了turn，那我们先执行了，对面先等着 // 先修改 turn 的才能跳出这个 while，也就是手快有手慢无 } void unlock() { flag[self] = 0; } test-and-set 这种想法基于自旋锁（也就是只通过一个 flag 区分是否上锁），但是不依赖硬件显然不行，因为更精妙的 Peterson 都行不通。 x86 提供了与以下 C 代码类似的原子指令，硬件保证这个过程的原子性： // not code, but hardware implemented atomic test-and-set operation int TEST_AND_SET(int *old_ptr, int new) { int old = *old_ptr; *old_ptr = new; return old; } // 也就是把值改成新的，返回旧值 这样我们终于能够设计年轻人的第一把锁了：\n// this is C code!!! ","permalink":"http://localhost:4449/posts/os6-2/","summary":"作为无畏并发的基本手段，有必要复习一下设计锁的方法。","title":"操作系统复习·锁"},{"content":" 学而不思则罔，思而不学则殆。\n我们主要参考 sploitfun 先生的 Understanding glibc malloc 一文，对 malloc 的实现进行认真的学习和分析，最后形成了几张图解，比较全面地概括了相关的数据结构和算法。\n","permalink":"http://localhost:4449/posts/os6-1/","summary":"无论是操作系统内部还是应用程序，无论是单核 CPU 还是多核 CPU，堆分配都是操作系统实现和改良的核心话题之一。","title":"操作系统复习·堆分配"},{"content":"开发操作系统是我从小到大的梦想。但在追逐这个梦想的道路上我走了不少的弯路。\n初中的时候，我因为写 VBS 脚本装 B 认识了一位很好的朋友。我们一起讨论和学习 VBS，后来是 HTML，再后来是 VB 和 C#。那时候的我们相信，写一个操作系统是全天下最牛逼的事情。但就这点本事怎么可能写操作系统呢？我选择了用 PPT 来 “设计” “操作系统”，搞出一个 “Windows 13” 来。我的朋友选择用 C# 来模拟 Windows 的外观和基本功能，这样就看起来像是一个操作系统了。在这个 PPT 里，我通过 PowerPoint 内置的 VBA 写了一个记事本功能的“Word 2019”，那是我写的第一个程序。\n图 1 我用 PPT “设计” 的 “Windows 13.5” （微软请原谅我糟糕的美术知识）\n图 2 在另一个朋友制作的“手机”上搭载 “Windows 13 Phone”，那时的我可以很快画出 Win10 的 Hero 壁纸\n图 3 “也许 N 年后，Windows 13 系列会有后续，但那时，也许就不再是 PPT 了”\n高中的时候，我仍然在有限的空闲时间内继续空想一个操作系统。一方面，在闲暇时间，手边又没有电脑，我会手绘一些想到的“产品设计”；另一方面，我了解到有《30天自制操作系统》这本书，还在网上找了一些很有意思的教程，打算在有空闲时间时大干一场。\n图 4 我使用汇编语言写了第一个裸机应用程序 “Hello World”\n图 5 我那时还在着迷于所谓的“产品设计”\n可惜的是，那时候的空闲时间实在太少，我还把大部分时间用来开发一个在班级白板上使用的教学助手。等到有时间实践网上找到的操作系统教程时，却被汇编语言的难度和连接国际互联网的问题（那时不配置 apt 源在国内是用不成 apt 的。对于一个使用 Windows 很多年的爱好者，我在刚开始并没有找到学习 Ubuntu 的合理路径，被大量不熟悉的细节给围殴了。而且没有 Google 很多问题也没法完全搞清楚。）困扰了很久，最后还是放弃了。对那时的我，访问 Github 都得靠运气——据说早上九点是个好的时间。\n再后来，我成功得偿所愿进入计算机系学习。和操作系统相关的第一次尝试是数电实验课程。我那时仍然空想在我设计的 rv32ui 指令集的用 FPGA 模拟的 CPU 上运行自己写的操作系统——可是没有特权指令集，这怎么可能呢？最后，我仍然只实现了一个简陋的裸机终端。不过因为以往的这些执念，我没有组小组，而是一个人完成了从 CPU 设计到终端开发的全部工作——其实应该去 Github 找找裸机终端的代码的，那时候还是太年轻了。\n图 6 minTerminal 的架构图。那时的我很骄傲独立完成了这个项目\n现在的我，学习完了操作系统课程，认识到自己以前幼稚的探索确实错过了很多学习知识、实现梦想的机会。但蓦然回首，我发现我已经可以学习一个优秀的内核实现的全部代码了，我有信心掌握全部的细节。而且，还有《Operating Systems: Three Easy Pieces》这样优秀的教材。这比自己碰壁，在知乎上找“操作系统教程”有意义的多。\n好了，说了这么多废话，最后还是希望自己能坚持下来吧。\n","permalink":"http://localhost:4449/posts/os6-0/","summary":"本节内容和技术无关，纯属瞎唠叨。","title":"操作系统复习·前言"},{"content":"项目地址（配有使用方法）：https://github.com/HazeMa0/fly-hadoop2-workflow\n作为博客，还是整理一下这个过程中的困难吧。\n一、网络问题很烦人 首先，事实是：2024 年，中国大陆的主要高校和云服务商都关闭了 Docker Hub 的镜像源。但是百度仍有大量的帖子在建议更换镜像源以改善对 Docker Hub 的访问。\n我在我的 Windows 环境部署了代理。WSL2 理应继承代理设置。但是神奇的事情发生了：WSL2 我们可以顺利地 docker build，Windows 却不行。\n然后，我们做了以下事情试图让 Dockerfile 的 from 指令正常工作：\n设置 HTTP_PROXY 和 HTTPS_PROXY 环境变量； 注意！\nHTTPS_PROXY 对应的仍然是 http://localhost:1234，而不是 https！我是在发现环境变量使我的 VSCode 无法正常工作时才发现这个问题的；\n配置 Docker Engine 的配置文件： \u0026#34;proxies\u0026#34;: { \u0026#34;default\u0026#34;: { \u0026#34;httpProxy\u0026#34;: \u0026#34;http://127.0.0.1:9870\u0026#34;, \u0026#34;httpsProxy\u0026#34;: \u0026#34;http://127.0.0.1:9870\u0026#34;, \u0026#34;noProxy\u0026#34;: \u0026#34;localhost,127.0.0.1\u0026#34; } } 修改 ~/.docker/config.json（最后又删掉了） 在我没发现我把 HTTPS_PROXY 写成 https://\u0026hellip; 时，这三个修改都不起作用。然后，在一次神秘的 docker pull ... 后，突然就好起来了，我至今也没搞清楚到底是怎么回事。\n我们认识到，ping 命令走的是 ICMP 协议，对测试 http/socks5 的代理没有意义。 二、对 Docker 和 Dev Container 的错误理解 刚开始，我们在使用 Docker 运行和使用 Dev Container 作为开发环境上犹豫和摇摆了很长时间。我问了 AI 下面这一大段文字，可见我当时的烦躁。\n我现在陷入了一些混乱，需要你来拯救我。要写代码，首先要有开发环境。一般来说，这意味着编译器和解释器以及外部库和系统库的版本，还有代码构建工具的版本。这些东西在不同的开发项目中很容易冲突。然后我们运行起来了程序。然后希望交给测试测试。我没有在公司工作过，我不知道测试测试时需不需要源代码，还是只拿最终可执行程序进行测试。如果需要，那他也需要开发环境。然后经过修改，最后交付用户。用户不同软件之间的运行环境也可能冲突，一般来说，运行环境应该是开发环境的一个子集。容器要怎么终结这一系列混乱？\n好了，现在产生了问题。首先开发者要搭建一个叫做开发环境的玩意。把编译器/解释器/代码生成程序/外部库/系统库封装在容器里面是很好，问题是本地运行的IDE怎么和这些容器里面的玩意交互，从而支持语法高亮和其他功能呢？其次，我说了，运行环境往往是开发环境的子集，编译器对运行环境毫无必要。难道容器通过纵容这些冗余来换取分发效率吗？还有，为什么现实中面向普通用户的应用没有一个用docker分发呢？\n产生这些困惑的 Docker 相关问题是：\n以为代码的依赖都在容器里面，不希望手动把依赖拷到物理机恶心自己。虽然我们确实可以在容器里面援引相关的 jar，但更方便的方法是直接在本地通过 Maven 从中心仓库部署合适的依赖用于测试。 不了解容器挂载技术，以为我们必须手动把 jar 文件拷贝到容器测试。 不了解本地测试 Hadoop，以为所有类型的测试必须使用 hadoop jar 命令执行。实际上我们甚至可以不启动容器进行本地测试，完全本地开发。 区分不了镜像和容器。镜像是死的初始化状态，容器是基于镜像的可工作的实体。Dockerfile 产生镜像。 过早把自己摆到用户角度，认为开发环境对运行环境是冗余的（冗余了你改改 Dockerfile 不就行了吗，对刚开始的我来说改这玩意很困难，现在完全不是了） Dev Container 相关问题是：\n神圣化 Dev Container，以为其不会往容器里面部署 IDE 后端，从而产生了一系列矛盾； 以为 Dev Container 不能配置容器开放的端口。同时认识到，不能修改一个已经打开的容器的端口映射，这是为了简化容器运行状态故意为之的设计。 Dev Container 指定 entrypoint 不是在 postCreateCommand，也不是在 Dockerfile，只有通过 runArgs 指定才是正确的。 不知道为什么，让 Dev Container 执行我的脚本时不能正确识别 echo 的 -e 参数，而是将其作为文本打印。最后我们换用了 printf 命令。 三、一些 linux 知识 Hadoop 环境初始化脚本需要 ssh 连接，就会产生下面这种需要手动确认的麻烦问题： yes：The authenticity of host \u0026#39;localhost (::1)\u0026#39; can\u0026#39;t be established. ECDSA key fingerprint is SHA256:**********.\rAre you sure you want to continue connecting (yes/no)? 我们希望初始化脚本作为 Docker 的 1 号进程，当然不希望这种需要手工确认的东西出现。我们最终使用以下脚本解决：\ntouch ~/.ssh/config printf \u0026#34;Host *\\n\\tStrictHostKeyChecking no\\n\\tUserKnownHostsFile /dev/null\\n\u0026#34; \u0026gt; ~/.ssh/config 该死的 \\r\\n 在 Windows，git 默认会把 \\n 替换成 \\r\\n。这最后导致我的脚本 push 再 clone 后竟然无法运行了。最后一行命令解决问题： git config --global core.autocrlf false 有趣的事实：JDK 1.x == JDK x 四、该死的讲义问题 讲义给出的一些命令根本是错误的。\n讲义没有细说应该怎么修改 Hadoop 的若干 xml，百度也在画蛇添足。只有官方文档才是可靠的。\n讲义没告诉我 start-all.sh 的正确位置，让我无法正确配置 PATH。\n五、鸣谢 感谢 DeepSeek 和 ChatGPT 耐心地听我抱怨和提出问题。没有任何一个人类受得了这么多怨气和不满。\n感谢官方的 Hadoop 安装教程。\n感谢 Google。珍爱生命，拒绝百度。\n","permalink":"http://localhost:4449/posts/fly-hadoop2-workflow/","summary":"项目地址：https://github.com/HazeMa0/fly-hadoop2-workflow。借助 Docker 和 Dev Container，舒适地开发老旧框架的程序。本文阐述了这个项目中遇到的困难。","title":"fly-hadoop2-workflow：让编写 hadoop 2.7 应用的效率飞起来"},{"content":" 相关软件（不限版本）\nnautilus 刚装好 Ubuntu，我们在文件管理器的右键菜单里面找不到新建文件的选项，这确实很让人匪夷所思。\n实际上，我们只需要在 ~/Templates 新建一个模板就好。\n$ cd ~/Templates $ touch `TXT.txt` $ touch `Markdown.md` 当然这个方案并不完美，就是并没有在新建文件后自动处于重命名状态的功能。\n","permalink":"http://localhost:4449/posts/nautilus-new-file/","summary":"为 nautilus 添加新建选项的菜单并不困难。因为 ~/Templates 就是专门为之服务的。","title":"如何为 nautilus 右键菜单添加新建文件选项"},{"content":" 相关软件版本\nUbuntu 22.04 及以上 nautilus 是 GNOME 桌面环境默认的 GUI 文件管理器。\n本来其实没想到这样一个简单的任务会引起一些麻烦。把我处理这个麻烦的过程记下来吧。\n首先，我们百度搜索这个问题，从一些相当新的帖子获得的解决方案是安装 nautilus-actions。但意外的是，在 Ubuntu 22.04 中，这个包被移除了。\n我们转战谷歌，找到了这篇帖子，告诉我们这个软件因为缺少更新已经被上游的 gnome 存档了。我们也并不想使用已经被废弃的软件，那就去找替代方案吧——我相信不可能没有提供。\n意外发现：gnome 原来用 gitlab 管理项目，有趣。\n翻译者没有兴趣维护这个软件：\u0026ldquo;Sorry, but if there\u0026rsquo;s no contributions for several years, we\u0026rsquo;re not going to keep it active. It wastes the efforts of our translators. Feel free to fork and maintain it somewhere else if you like (it\u0026rsquo;s open source, after all).\u0026rdquo;\n另一篇帖子 指出了两个替代方案：一个是我在以前使用过的 Nautilus Scripts，最终效果是在右键菜单里面显示一个 Scripts 子菜单，里面有我们写好的脚本作为选项。这种方法不够优雅，我们希望显示在主右键菜单里面；另一个是 nautilus-python，出于对 python 的好感我们最终选择这个方案。\n问题又来了，在 Ubuntu 安装 nautilus-python，也没有这个包。经过检查，一篇帖子 指出其在 Ubuntu 源的名称是 python3-nautilus，这可能是因为一些误解产生的问题。\n现在我们学习写 python 代码来实现 nautilus-python 的扩展。参考资源：官方示例、linuxconfig.org 的教程。我们将写好的 python 文件保存到 ~/.local/share/nautilus-python/extensions/ 即可，然后重启 nautilus 即可。\n先看下面的示例，其为 VSCode 打开文件夹和文件提供了右键菜单（使用命令 wget -qO- https://raw.githubusercontent.com/harry-cpp/code-nautilus/master/install.sh | bash 以快速安装，我对代码做了一些简化，原本的源代码请参考相应的 GitHub 仓库）：\nfrom gi.repository import Nautilus, GObject from subprocess import call import os class VSCodeExtension(GObject.GObject, Nautilus.MenuProvider): # python 支持多重继承 def launch_vscode(self, menu, files): # 参数是 self, menu, files，注意不要修改 safepaths = \u0026#39;\u0026#39; args = \u0026#39;\u0026#39; for file in files: filepath = file.get_location().get_path() safepaths += \u0026#39;\u0026#34;\u0026#39; + filepath + \u0026#39;\u0026#34; \u0026#39; if os.path.isdir(filepath) and os.path.exists(filepath): args = \u0026#39;--new-window \u0026#39; call(\u0026#39;code \u0026#39; + args + safepaths + \u0026#39;\u0026amp;\u0026#39;, shell=True) def get_file_items(self, *args): # 右键文件/文件夹时对应的方法 files = args[-1] item = Nautilus.MenuItem( name=\u0026#39;VSCodeOpen\u0026#39;, label=\u0026#39;Open in Code\u0026#39;, tip=\u0026#39;Opens the selected files with VSCode\u0026#39; ) item.connect(\u0026#39;activate\u0026#39;, self.launch_vscode, files) return [item] def get_background_items(self, *args): # 右键空白位置时的方法 file_ = args[-1] item = Nautilus.MenuItem( name=\u0026#39;VSCodeOpenBackground\u0026#39;, label=\u0026#39;Open in Code\u0026#39;, tip=\u0026#39;Opens the current directory in VSCode\u0026#39; ) item.connect(\u0026#39;activate\u0026#39;, self.launch_vscode, [file_]) return [item] 上面的 python 代码足够直观了。get_backgroud_items 和 get_file_items 返回一个菜单数组，而菜单如何创建和与具体的操作方法链接上面的示例已经足够说明。\n","permalink":"http://localhost:4449/posts/nautilus-right-click/","summary":"nautilus 是 GNOME 桌面环境默认的 GUI 文件管理器。本文介绍如何为 nautilus 添加自定义的右键菜单项。","title":"如何为 nautilus 配置右键菜单"},{"content":"","permalink":"http://localhost:4449/tags/","summary":"tags","title":"标签"},{"content":" 我，无畏并发。 《BanG Dream! Ave Mujica》（大嘘）\n一些基本的讨论 锁应当存放在大家共用的内存空间，总之不应该是栈。 一个好的锁应该提供正确的互斥、保障线程公平、性能优秀。 一些失败的想法 关中断：这很容易被滥用，导致系统接收不到中断信息；不适用于多处理器系统。 Peterson 算法：必须假设访存的原子性，但这一点现代硬件早就打破了。 int flag[2]; int turn; void init() { flag[0] = flag[1] = 0; turn = 0; } void lock() { flag[self] = 1; // 竖起自己的旗子 turn = 1 - self; // 让 turn 等于对面 // 我们假设对面此时也执行了这两句，turn 此时等于 self while((flag[1 - self] == 1) \u0026amp;\u0026amp; (turn == 1 - self)) ; // 因为对面改变了turn，那我们先执行了，对面先等着 // 先修改 turn 的才能跳出这个 while，也就是手快有手慢无 } void unlock() { flag[self] = 0; } test-and-set 这种想法基于自旋锁（也就是只通过一个 flag 区分是否上锁），但是不依赖硬件显然不行，因为更精妙的 Peterson 都行不通。 x86 提供了与以下 C 代码类似的原子指令，硬件保证这个过程的原子性： // not code, but hardware implemented atomic test-and-set operation int TEST_AND_SET(int *old_ptr, int new) { int old = *old_ptr; *old_ptr = new; return old; } // 也就是把值改成新的，返回旧值 这样我们终于能够设计年轻人的第一把锁了：\n// this is C code!!! ","permalink":"http://localhost:4449/posts/os6-2/","summary":"作为无畏并发的基本手段，有必要复习一下设计锁的方法。","title":"操作系统复习·锁"},{"content":" 学而不思则罔，思而不学则殆。\n我们主要参考 sploitfun 先生的 Understanding glibc malloc 一文，对 malloc 的实现进行认真的学习和分析，最后形成了几张图解，比较全面地概括了相关的数据结构和算法。\n","permalink":"http://localhost:4449/posts/os6-1/","summary":"无论是操作系统内部还是应用程序，无论是单核 CPU 还是多核 CPU，堆分配都是操作系统实现和改良的核心话题之一。","title":"操作系统复习·堆分配"},{"content":"开发操作系统是我从小到大的梦想。但在追逐这个梦想的道路上我走了不少的弯路。\n初中的时候，我因为写 VBS 脚本装 B 认识了一位很好的朋友。我们一起讨论和学习 VBS，后来是 HTML，再后来是 VB 和 C#。那时候的我们相信，写一个操作系统是全天下最牛逼的事情。但就这点本事怎么可能写操作系统呢？我选择了用 PPT 来 “设计” “操作系统”，搞出一个 “Windows 13” 来。我的朋友选择用 C# 来模拟 Windows 的外观和基本功能，这样就看起来像是一个操作系统了。在这个 PPT 里，我通过 PowerPoint 内置的 VBA 写了一个记事本功能的“Word 2019”，那是我写的第一个程序。\n图 1 我用 PPT “设计” 的 “Windows 13.5” （微软请原谅我糟糕的美术知识）\n图 2 在另一个朋友制作的“手机”上搭载 “Windows 13 Phone”，那时的我可以很快画出 Win10 的 Hero 壁纸\n图 3 “也许 N 年后，Windows 13 系列会有后续，但那时，也许就不再是 PPT 了”\n高中的时候，我仍然在有限的空闲时间内继续空想一个操作系统。一方面，在闲暇时间，手边又没有电脑，我会手绘一些想到的“产品设计”；另一方面，我了解到有《30天自制操作系统》这本书，还在网上找了一些很有意思的教程，打算在有空闲时间时大干一场。\n图 4 我使用汇编语言写了第一个裸机应用程序 “Hello World”\n图 5 我那时还在着迷于所谓的“产品设计”\n可惜的是，那时候的空闲时间实在太少，我还把大部分时间用来开发一个在班级白板上使用的教学助手。等到有时间实践网上找到的操作系统教程时，却被汇编语言的难度和连接国际互联网的问题（那时不配置 apt 源在国内是用不成 apt 的。对于一个使用 Windows 很多年的爱好者，我在刚开始并没有找到学习 Ubuntu 的合理路径，被大量不熟悉的细节给围殴了。而且没有 Google 很多问题也没法完全搞清楚。）困扰了很久，最后还是放弃了。对那时的我，访问 Github 都得靠运气——据说早上九点是个好的时间。\n再后来，我成功得偿所愿进入计算机系学习。和操作系统相关的第一次尝试是数电实验课程。我那时仍然空想在我设计的 rv32ui 指令集的用 FPGA 模拟的 CPU 上运行自己写的操作系统——可是没有特权指令集，这怎么可能呢？最后，我仍然只实现了一个简陋的裸机终端。不过因为以往的这些执念，我没有组小组，而是一个人完成了从 CPU 设计到终端开发的全部工作——其实应该去 Github 找找裸机终端的代码的，那时候还是太年轻了。\n图 6 minTerminal 的架构图。那时的我很骄傲独立完成了这个项目\n现在的我，学习完了操作系统课程，认识到自己以前幼稚的探索确实错过了很多学习知识、实现梦想的机会。但蓦然回首，我发现我已经可以学习一个优秀的内核实现的全部代码了，我有信心掌握全部的细节。而且，还有《Operating Systems: Three Easy Pieces》这样优秀的教材。这比自己碰壁，在知乎上找“操作系统教程”有意义的多。\n好了，说了这么多废话，最后还是希望自己能坚持下来吧。\n","permalink":"http://localhost:4449/posts/os6-0/","summary":"本节内容和技术无关，纯属瞎唠叨。","title":"操作系统复习·前言"},{"content":"项目地址（配有使用方法）：https://github.com/HazeMa0/fly-hadoop2-workflow\n作为博客，还是整理一下这个过程中的困难吧。\n一、网络问题很烦人 首先，事实是：2024 年，中国大陆的主要高校和云服务商都关闭了 Docker Hub 的镜像源。但是百度仍有大量的帖子在建议更换镜像源以改善对 Docker Hub 的访问。\n我在我的 Windows 环境部署了代理。WSL2 理应继承代理设置。但是神奇的事情发生了：WSL2 我们可以顺利地 docker build，Windows 却不行。\n然后，我们做了以下事情试图让 Dockerfile 的 from 指令正常工作：\n设置 HTTP_PROXY 和 HTTPS_PROXY 环境变量； 注意！\nHTTPS_PROXY 对应的仍然是 http://localhost:1234，而不是 https！我是在发现环境变量使我的 VSCode 无法正常工作时才发现这个问题的；\n配置 Docker Engine 的配置文件： \u0026#34;proxies\u0026#34;: { \u0026#34;default\u0026#34;: { \u0026#34;httpProxy\u0026#34;: \u0026#34;http://127.0.0.1:9870\u0026#34;, \u0026#34;httpsProxy\u0026#34;: \u0026#34;http://127.0.0.1:9870\u0026#34;, \u0026#34;noProxy\u0026#34;: \u0026#34;localhost,127.0.0.1\u0026#34; } } 修改 ~/.docker/config.json（最后又删掉了） 在我没发现我把 HTTPS_PROXY 写成 https://\u0026hellip; 时，这三个修改都不起作用。然后，在一次神秘的 docker pull ... 后，突然就好起来了，我至今也没搞清楚到底是怎么回事。\n我们认识到，ping 命令走的是 ICMP 协议，对测试 http/socks5 的代理没有意义。 二、对 Docker 和 Dev Container 的错误理解 刚开始，我们在使用 Docker 运行和使用 Dev Container 作为开发环境上犹豫和摇摆了很长时间。我问了 AI 下面这一大段文字，可见我当时的烦躁。\n我现在陷入了一些混乱，需要你来拯救我。要写代码，首先要有开发环境。一般来说，这意味着编译器和解释器以及外部库和系统库的版本，还有代码构建工具的版本。这些东西在不同的开发项目中很容易冲突。然后我们运行起来了程序。然后希望交给测试测试。我没有在公司工作过，我不知道测试测试时需不需要源代码，还是只拿最终可执行程序进行测试。如果需要，那他也需要开发环境。然后经过修改，最后交付用户。用户不同软件之间的运行环境也可能冲突，一般来说，运行环境应该是开发环境的一个子集。容器要怎么终结这一系列混乱？\n好了，现在产生了问题。首先开发者要搭建一个叫做开发环境的玩意。把编译器/解释器/代码生成程序/外部库/系统库封装在容器里面是很好，问题是本地运行的IDE怎么和这些容器里面的玩意交互，从而支持语法高亮和其他功能呢？其次，我说了，运行环境往往是开发环境的子集，编译器对运行环境毫无必要。难道容器通过纵容这些冗余来换取分发效率吗？还有，为什么现实中面向普通用户的应用没有一个用docker分发呢？\n产生这些困惑的 Docker 相关问题是：\n以为代码的依赖都在容器里面，不希望手动把依赖拷到物理机恶心自己。虽然我们确实可以在容器里面援引相关的 jar，但更方便的方法是直接在本地通过 Maven 从中心仓库部署合适的依赖用于测试。 不了解容器挂载技术，以为我们必须手动把 jar 文件拷贝到容器测试。 不了解本地测试 Hadoop，以为所有类型的测试必须使用 hadoop jar 命令执行。实际上我们甚至可以不启动容器进行本地测试，完全本地开发。 区分不了镜像和容器。镜像是死的初始化状态，容器是基于镜像的可工作的实体。Dockerfile 产生镜像。 过早把自己摆到用户角度，认为开发环境对运行环境是冗余的（冗余了你改改 Dockerfile 不就行了吗，对刚开始的我来说改这玩意很困难，现在完全不是了） Dev Container 相关问题是：\n神圣化 Dev Container，以为其不会往容器里面部署 IDE 后端，从而产生了一系列矛盾； 以为 Dev Container 不能配置容器开放的端口。同时认识到，不能修改一个已经打开的容器的端口映射，这是为了简化容器运行状态故意为之的设计。 Dev Container 指定 entrypoint 不是在 postCreateCommand，也不是在 Dockerfile，只有通过 runArgs 指定才是正确的。 不知道为什么，让 Dev Container 执行我的脚本时不能正确识别 echo 的 -e 参数，而是将其作为文本打印。最后我们换用了 printf 命令。 三、一些 linux 知识 Hadoop 环境初始化脚本需要 ssh 连接，就会产生下面这种需要手动确认的麻烦问题： yes：The authenticity of host \u0026#39;localhost (::1)\u0026#39; can\u0026#39;t be established. ECDSA key fingerprint is SHA256:**********.\rAre you sure you want to continue connecting (yes/no)? 我们希望初始化脚本作为 Docker 的 1 号进程，当然不希望这种需要手工确认的东西出现。我们最终使用以下脚本解决：\ntouch ~/.ssh/config printf \u0026#34;Host *\\n\\tStrictHostKeyChecking no\\n\\tUserKnownHostsFile /dev/null\\n\u0026#34; \u0026gt; ~/.ssh/config 该死的 \\r\\n 在 Windows，git 默认会把 \\n 替换成 \\r\\n。这最后导致我的脚本 push 再 clone 后竟然无法运行了。最后一行命令解决问题： git config --global core.autocrlf false 有趣的事实：JDK 1.x == JDK x 四、该死的讲义问题 讲义给出的一些命令根本是错误的。\n讲义没有细说应该怎么修改 Hadoop 的若干 xml，百度也在画蛇添足。只有官方文档才是可靠的。\n讲义没告诉我 start-all.sh 的正确位置，让我无法正确配置 PATH。\n五、鸣谢 感谢 DeepSeek 和 ChatGPT 耐心地听我抱怨和提出问题。没有任何一个人类受得了这么多怨气和不满。\n感谢官方的 Hadoop 安装教程。\n感谢 Google。珍爱生命，拒绝百度。\n","permalink":"http://localhost:4449/posts/fly-hadoop2-workflow/","summary":"项目地址：https://github.com/HazeMa0/fly-hadoop2-workflow。借助 Docker 和 Dev Container，舒适地开发老旧框架的程序。本文阐述了这个项目中遇到的困难。","title":"fly-hadoop2-workflow：让编写 hadoop 2.7 应用的效率飞起来"},{"content":" 相关软件（不限版本）\nnautilus 刚装好 Ubuntu，我们在文件管理器的右键菜单里面找不到新建文件的选项，这确实很让人匪夷所思。\n实际上，我们只需要在 ~/Templates 新建一个模板就好。\n$ cd ~/Templates $ touch `TXT.txt` $ touch `Markdown.md` 当然这个方案并不完美，就是并没有在新建文件后自动处于重命名状态的功能。\n","permalink":"http://localhost:4449/posts/nautilus-new-file/","summary":"为 nautilus 添加新建选项的菜单并不困难。因为 ~/Templates 就是专门为之服务的。","title":"如何为 nautilus 右键菜单添加新建文件选项"},{"content":" 相关软件版本\nUbuntu 22.04 及以上 nautilus 是 GNOME 桌面环境默认的 GUI 文件管理器。\n本来其实没想到这样一个简单的任务会引起一些麻烦。把我处理这个麻烦的过程记下来吧。\n首先，我们百度搜索这个问题，从一些相当新的帖子获得的解决方案是安装 nautilus-actions。但意外的是，在 Ubuntu 22.04 中，这个包被移除了。\n我们转战谷歌，找到了这篇帖子，告诉我们这个软件因为缺少更新已经被上游的 gnome 存档了。我们也并不想使用已经被废弃的软件，那就去找替代方案吧——我相信不可能没有提供。\n意外发现：gnome 原来用 gitlab 管理项目，有趣。\n翻译者没有兴趣维护这个软件：\u0026ldquo;Sorry, but if there\u0026rsquo;s no contributions for several years, we\u0026rsquo;re not going to keep it active. It wastes the efforts of our translators. Feel free to fork and maintain it somewhere else if you like (it\u0026rsquo;s open source, after all).\u0026rdquo;\n另一篇帖子 指出了两个替代方案：一个是我在以前使用过的 Nautilus Scripts，最终效果是在右键菜单里面显示一个 Scripts 子菜单，里面有我们写好的脚本作为选项。这种方法不够优雅，我们希望显示在主右键菜单里面；另一个是 nautilus-python，出于对 python 的好感我们最终选择这个方案。\n问题又来了，在 Ubuntu 安装 nautilus-python，也没有这个包。经过检查，一篇帖子 指出其在 Ubuntu 源的名称是 python3-nautilus，这可能是因为一些误解产生的问题。\n现在我们学习写 python 代码来实现 nautilus-python 的扩展。参考资源：官方示例、linuxconfig.org 的教程。我们将写好的 python 文件保存到 ~/.local/share/nautilus-python/extensions/ 即可，然后重启 nautilus 即可。\n先看下面的示例，其为 VSCode 打开文件夹和文件提供了右键菜单（使用命令 wget -qO- https://raw.githubusercontent.com/harry-cpp/code-nautilus/master/install.sh | bash 以快速安装，我对代码做了一些简化，原本的源代码请参考相应的 GitHub 仓库）：\nfrom gi.repository import Nautilus, GObject from subprocess import call import os class VSCodeExtension(GObject.GObject, Nautilus.MenuProvider): # python 支持多重继承 def launch_vscode(self, menu, files): # 参数是 self, menu, files，注意不要修改 safepaths = \u0026#39;\u0026#39; args = \u0026#39;\u0026#39; for file in files: filepath = file.get_location().get_path() safepaths += \u0026#39;\u0026#34;\u0026#39; + filepath + \u0026#39;\u0026#34; \u0026#39; if os.path.isdir(filepath) and os.path.exists(filepath): args = \u0026#39;--new-window \u0026#39; call(\u0026#39;code \u0026#39; + args + safepaths + \u0026#39;\u0026amp;\u0026#39;, shell=True) def get_file_items(self, *args): # 右键文件/文件夹时对应的方法 files = args[-1] item = Nautilus.MenuItem( name=\u0026#39;VSCodeOpen\u0026#39;, label=\u0026#39;Open in Code\u0026#39;, tip=\u0026#39;Opens the selected files with VSCode\u0026#39; ) item.connect(\u0026#39;activate\u0026#39;, self.launch_vscode, files) return [item] def get_background_items(self, *args): # 右键空白位置时的方法 file_ = args[-1] item = Nautilus.MenuItem( name=\u0026#39;VSCodeOpenBackground\u0026#39;, label=\u0026#39;Open in Code\u0026#39;, tip=\u0026#39;Opens the current directory in VSCode\u0026#39; ) item.connect(\u0026#39;activate\u0026#39;, self.launch_vscode, [file_]) return [item] 上面的 python 代码足够直观了。get_backgroud_items 和 get_file_items 返回一个菜单数组，而菜单如何创建和与具体的操作方法链接上面的示例已经足够说明。\n","permalink":"http://localhost:4449/posts/nautilus-right-click/","summary":"nautilus 是 GNOME 桌面环境默认的 GUI 文件管理器。本文介绍如何为 nautilus 添加自定义的右键菜单项。","title":"如何为 nautilus 配置右键菜单"},{"content":"","permalink":"http://localhost:4449/tags/","summary":"tags","title":"标签"},{"content":" 我，无畏并发。 《BanG Dream! Ave Mujica》（大嘘）\n零、一些基本的讨论 锁应当存放在大家共用的内存空间，总之不应该是栈。 一个好的锁应该提供正确的互斥、保障线程公平、性能优秀。 零、一些失败的想法 关中断：这很容易被滥用，导致系统接收不到中断信息；不适用于多处理器系统。 Peterson 算法：必须假设访存的原子性，但这一点现代硬件早就打破了。 int flag[2]; int turn; void init() { flag[0] = flag[1] = 0; turn = 0; } void lock() { flag[self] = 1; // 竖起自己的旗子 turn = 1 - self; // 让 turn 等于对面 // 我们假设对面此时也执行了这两句，turn 此时等于 self while((flag[1 - self] == 1) \u0026amp;\u0026amp; (turn == 1 - self)) ; // 因为对面改变了turn，那我们先执行了，对面先等着 // 先修改 turn 的才能跳出这个 while，也就是手快有手慢无 } void unlock() { flag[self] = 0; } test-and-set 这种想法基于自旋锁（也就是只通过一个 flag 区分是否上锁），但是不依赖硬件显然不行，因为更精妙的 Peterson 都行不通。 x86 提供了与以下 C 代码类似的原子指令，硬件保证这个过程的原子性： // not code, but hardware implemented atomic test-and-set operation int TEST_AND_SET(int *old_ptr, int new) { int old = *old_ptr; *old_ptr = new; return old; } // 也就是把值改成新的，返回旧值 这样我们终于能够设计年轻人的第一把锁了：\n// this is C code!!! ","permalink":"http://localhost:4449/posts/os6-2/","summary":"作为无畏并发的基本手段，有必要复习一下设计锁的方法。","title":"操作系统复习·锁"},{"content":" 学而不思则罔，思而不学则殆。\n我们主要参考 sploitfun 先生的 Understanding glibc malloc 一文，对 malloc 的实现进行认真的学习和分析，最后形成了几张图解，比较全面地概括了相关的数据结构和算法。\n","permalink":"http://localhost:4449/posts/os6-1/","summary":"无论是操作系统内部还是应用程序，无论是单核 CPU 还是多核 CPU，堆分配都是操作系统实现和改良的核心话题之一。","title":"操作系统复习·堆分配"},{"content":"开发操作系统是我从小到大的梦想。但在追逐这个梦想的道路上我走了不少的弯路。\n初中的时候，我因为写 VBS 脚本装 B 认识了一位很好的朋友。我们一起讨论和学习 VBS，后来是 HTML，再后来是 VB 和 C#。那时候的我们相信，写一个操作系统是全天下最牛逼的事情。但就这点本事怎么可能写操作系统呢？我选择了用 PPT 来 “设计” “操作系统”，搞出一个 “Windows 13” 来。我的朋友选择用 C# 来模拟 Windows 的外观和基本功能，这样就看起来像是一个操作系统了。在这个 PPT 里，我通过 PowerPoint 内置的 VBA 写了一个记事本功能的“Word 2019”，那是我写的第一个程序。\n图 1 我用 PPT “设计” 的 “Windows 13.5” （微软请原谅我糟糕的美术知识）\n图 2 在另一个朋友制作的“手机”上搭载 “Windows 13 Phone”，那时的我可以很快画出 Win10 的 Hero 壁纸\n图 3 “也许 N 年后，Windows 13 系列会有后续，但那时，也许就不再是 PPT 了”\n高中的时候，我仍然在有限的空闲时间内继续空想一个操作系统。一方面，在闲暇时间，手边又没有电脑，我会手绘一些想到的“产品设计”；另一方面，我了解到有《30天自制操作系统》这本书，还在网上找了一些很有意思的教程，打算在有空闲时间时大干一场。\n图 4 我使用汇编语言写了第一个裸机应用程序 “Hello World”\n图 5 我那时还在着迷于所谓的“产品设计”\n可惜的是，那时候的空闲时间实在太少，我还把大部分时间用来开发一个在班级白板上使用的教学助手。等到有时间实践网上找到的操作系统教程时，却被汇编语言的难度和连接国际互联网的问题（那时不配置 apt 源在国内是用不成 apt 的。对于一个使用 Windows 很多年的爱好者，我在刚开始并没有找到学习 Ubuntu 的合理路径，被大量不熟悉的细节给围殴了。而且没有 Google 很多问题也没法完全搞清楚。）困扰了很久，最后还是放弃了。对那时的我，访问 Github 都得靠运气——据说早上九点是个好的时间。\n再后来，我成功得偿所愿进入计算机系学习。和操作系统相关的第一次尝试是数电实验课程。我那时仍然空想在我设计的 rv32ui 指令集的用 FPGA 模拟的 CPU 上运行自己写的操作系统——可是没有特权指令集，这怎么可能呢？最后，我仍然只实现了一个简陋的裸机终端。不过因为以往的这些执念，我没有组小组，而是一个人完成了从 CPU 设计到终端开发的全部工作——其实应该去 Github 找找裸机终端的代码的，那时候还是太年轻了。\n图 6 minTerminal 的架构图。那时的我很骄傲独立完成了这个项目\n现在的我，学习完了操作系统课程，认识到自己以前幼稚的探索确实错过了很多学习知识、实现梦想的机会。但蓦然回首，我发现我已经可以学习一个优秀的内核实现的全部代码了，我有信心掌握全部的细节。而且，还有《Operating Systems: Three Easy Pieces》这样优秀的教材。这比自己碰壁，在知乎上找“操作系统教程”有意义的多。\n好了，说了这么多废话，最后还是希望自己能坚持下来吧。\n","permalink":"http://localhost:4449/posts/os6-0/","summary":"本节内容和技术无关，纯属瞎唠叨。","title":"操作系统复习·前言"},{"content":"项目地址（配有使用方法）：https://github.com/HazeMa0/fly-hadoop2-workflow\n作为博客，还是整理一下这个过程中的困难吧。\n一、网络问题很烦人 首先，事实是：2024 年，中国大陆的主要高校和云服务商都关闭了 Docker Hub 的镜像源。但是百度仍有大量的帖子在建议更换镜像源以改善对 Docker Hub 的访问。\n我在我的 Windows 环境部署了代理。WSL2 理应继承代理设置。但是神奇的事情发生了：WSL2 我们可以顺利地 docker build，Windows 却不行。\n然后，我们做了以下事情试图让 Dockerfile 的 from 指令正常工作：\n设置 HTTP_PROXY 和 HTTPS_PROXY 环境变量； 注意！\nHTTPS_PROXY 对应的仍然是 http://localhost:1234，而不是 https！我是在发现环境变量使我的 VSCode 无法正常工作时才发现这个问题的；\n配置 Docker Engine 的配置文件： \u0026#34;proxies\u0026#34;: { \u0026#34;default\u0026#34;: { \u0026#34;httpProxy\u0026#34;: \u0026#34;http://127.0.0.1:9870\u0026#34;, \u0026#34;httpsProxy\u0026#34;: \u0026#34;http://127.0.0.1:9870\u0026#34;, \u0026#34;noProxy\u0026#34;: \u0026#34;localhost,127.0.0.1\u0026#34; } } 修改 ~/.docker/config.json（最后又删掉了） 在我没发现我把 HTTPS_PROXY 写成 https://\u0026hellip; 时，这三个修改都不起作用。然后，在一次神秘的 docker pull ... 后，突然就好起来了，我至今也没搞清楚到底是怎么回事。\n我们认识到，ping 命令走的是 ICMP 协议，对测试 http/socks5 的代理没有意义。 二、对 Docker 和 Dev Container 的错误理解 刚开始，我们在使用 Docker 运行和使用 Dev Container 作为开发环境上犹豫和摇摆了很长时间。我问了 AI 下面这一大段文字，可见我当时的烦躁。\n我现在陷入了一些混乱，需要你来拯救我。要写代码，首先要有开发环境。一般来说，这意味着编译器和解释器以及外部库和系统库的版本，还有代码构建工具的版本。这些东西在不同的开发项目中很容易冲突。然后我们运行起来了程序。然后希望交给测试测试。我没有在公司工作过，我不知道测试测试时需不需要源代码，还是只拿最终可执行程序进行测试。如果需要，那他也需要开发环境。然后经过修改，最后交付用户。用户不同软件之间的运行环境也可能冲突，一般来说，运行环境应该是开发环境的一个子集。容器要怎么终结这一系列混乱？\n好了，现在产生了问题。首先开发者要搭建一个叫做开发环境的玩意。把编译器/解释器/代码生成程序/外部库/系统库封装在容器里面是很好，问题是本地运行的IDE怎么和这些容器里面的玩意交互，从而支持语法高亮和其他功能呢？其次，我说了，运行环境往往是开发环境的子集，编译器对运行环境毫无必要。难道容器通过纵容这些冗余来换取分发效率吗？还有，为什么现实中面向普通用户的应用没有一个用docker分发呢？\n产生这些困惑的 Docker 相关问题是：\n以为代码的依赖都在容器里面，不希望手动把依赖拷到物理机恶心自己。虽然我们确实可以在容器里面援引相关的 jar，但更方便的方法是直接在本地通过 Maven 从中心仓库部署合适的依赖用于测试。 不了解容器挂载技术，以为我们必须手动把 jar 文件拷贝到容器测试。 不了解本地测试 Hadoop，以为所有类型的测试必须使用 hadoop jar 命令执行。实际上我们甚至可以不启动容器进行本地测试，完全本地开发。 区分不了镜像和容器。镜像是死的初始化状态，容器是基于镜像的可工作的实体。Dockerfile 产生镜像。 过早把自己摆到用户角度，认为开发环境对运行环境是冗余的（冗余了你改改 Dockerfile 不就行了吗，对刚开始的我来说改这玩意很困难，现在完全不是了） Dev Container 相关问题是：\n神圣化 Dev Container，以为其不会往容器里面部署 IDE 后端，从而产生了一系列矛盾； 以为 Dev Container 不能配置容器开放的端口。同时认识到，不能修改一个已经打开的容器的端口映射，这是为了简化容器运行状态故意为之的设计。 Dev Container 指定 entrypoint 不是在 postCreateCommand，也不是在 Dockerfile，只有通过 runArgs 指定才是正确的。 不知道为什么，让 Dev Container 执行我的脚本时不能正确识别 echo 的 -e 参数，而是将其作为文本打印。最后我们换用了 printf 命令。 三、一些 linux 知识 Hadoop 环境初始化脚本需要 ssh 连接，就会产生下面这种需要手动确认的麻烦问题： yes：The authenticity of host \u0026#39;localhost (::1)\u0026#39; can\u0026#39;t be established. ECDSA key fingerprint is SHA256:**********.\rAre you sure you want to continue connecting (yes/no)? 我们希望初始化脚本作为 Docker 的 1 号进程，当然不希望这种需要手工确认的东西出现。我们最终使用以下脚本解决：\ntouch ~/.ssh/config printf \u0026#34;Host *\\n\\tStrictHostKeyChecking no\\n\\tUserKnownHostsFile /dev/null\\n\u0026#34; \u0026gt; ~/.ssh/config 该死的 \\r\\n 在 Windows，git 默认会把 \\n 替换成 \\r\\n。这最后导致我的脚本 push 再 clone 后竟然无法运行了。最后一行命令解决问题： git config --global core.autocrlf false 有趣的事实：JDK 1.x == JDK x 四、该死的讲义问题 讲义给出的一些命令根本是错误的。\n讲义没有细说应该怎么修改 Hadoop 的若干 xml，百度也在画蛇添足。只有官方文档才是可靠的。\n讲义没告诉我 start-all.sh 的正确位置，让我无法正确配置 PATH。\n五、鸣谢 感谢 DeepSeek 和 ChatGPT 耐心地听我抱怨和提出问题。没有任何一个人类受得了这么多怨气和不满。\n感谢官方的 Hadoop 安装教程。\n感谢 Google。珍爱生命，拒绝百度。\n","permalink":"http://localhost:4449/posts/fly-hadoop2-workflow/","summary":"项目地址：https://github.com/HazeMa0/fly-hadoop2-workflow。借助 Docker 和 Dev Container，舒适地开发老旧框架的程序。本文阐述了这个项目中遇到的困难。","title":"fly-hadoop2-workflow：让编写 hadoop 2.7 应用的效率飞起来"},{"content":" 相关软件（不限版本）\nnautilus 刚装好 Ubuntu，我们在文件管理器的右键菜单里面找不到新建文件的选项，这确实很让人匪夷所思。\n实际上，我们只需要在 ~/Templates 新建一个模板就好。\n$ cd ~/Templates $ touch `TXT.txt` $ touch `Markdown.md` 当然这个方案并不完美，就是并没有在新建文件后自动处于重命名状态的功能。\n","permalink":"http://localhost:4449/posts/nautilus-new-file/","summary":"为 nautilus 添加新建选项的菜单并不困难。因为 ~/Templates 就是专门为之服务的。","title":"如何为 nautilus 右键菜单添加新建文件选项"},{"content":" 相关软件版本\nUbuntu 22.04 及以上 nautilus 是 GNOME 桌面环境默认的 GUI 文件管理器。\n本来其实没想到这样一个简单的任务会引起一些麻烦。把我处理这个麻烦的过程记下来吧。\n首先，我们百度搜索这个问题，从一些相当新的帖子获得的解决方案是安装 nautilus-actions。但意外的是，在 Ubuntu 22.04 中，这个包被移除了。\n我们转战谷歌，找到了这篇帖子，告诉我们这个软件因为缺少更新已经被上游的 gnome 存档了。我们也并不想使用已经被废弃的软件，那就去找替代方案吧——我相信不可能没有提供。\n意外发现：gnome 原来用 gitlab 管理项目，有趣。\n翻译者没有兴趣维护这个软件：\u0026ldquo;Sorry, but if there\u0026rsquo;s no contributions for several years, we\u0026rsquo;re not going to keep it active. It wastes the efforts of our translators. Feel free to fork and maintain it somewhere else if you like (it\u0026rsquo;s open source, after all).\u0026rdquo;\n另一篇帖子 指出了两个替代方案：一个是我在以前使用过的 Nautilus Scripts，最终效果是在右键菜单里面显示一个 Scripts 子菜单，里面有我们写好的脚本作为选项。这种方法不够优雅，我们希望显示在主右键菜单里面；另一个是 nautilus-python，出于对 python 的好感我们最终选择这个方案。\n问题又来了，在 Ubuntu 安装 nautilus-python，也没有这个包。经过检查，一篇帖子 指出其在 Ubuntu 源的名称是 python3-nautilus，这可能是因为一些误解产生的问题。\n现在我们学习写 python 代码来实现 nautilus-python 的扩展。参考资源：官方示例、linuxconfig.org 的教程。我们将写好的 python 文件保存到 ~/.local/share/nautilus-python/extensions/ 即可，然后重启 nautilus 即可。\n先看下面的示例，其为 VSCode 打开文件夹和文件提供了右键菜单（使用命令 wget -qO- https://raw.githubusercontent.com/harry-cpp/code-nautilus/master/install.sh | bash 以快速安装，我对代码做了一些简化，原本的源代码请参考相应的 GitHub 仓库）：\nfrom gi.repository import Nautilus, GObject from subprocess import call import os class VSCodeExtension(GObject.GObject, Nautilus.MenuProvider): # python 支持多重继承 def launch_vscode(self, menu, files): # 参数是 self, menu, files，注意不要修改 safepaths = \u0026#39;\u0026#39; args = \u0026#39;\u0026#39; for file in files: filepath = file.get_location().get_path() safepaths += \u0026#39;\u0026#34;\u0026#39; + filepath + \u0026#39;\u0026#34; \u0026#39; if os.path.isdir(filepath) and os.path.exists(filepath): args = \u0026#39;--new-window \u0026#39; call(\u0026#39;code \u0026#39; + args + safepaths + \u0026#39;\u0026amp;\u0026#39;, shell=True) def get_file_items(self, *args): # 右键文件/文件夹时对应的方法 files = args[-1] item = Nautilus.MenuItem( name=\u0026#39;VSCodeOpen\u0026#39;, label=\u0026#39;Open in Code\u0026#39;, tip=\u0026#39;Opens the selected files with VSCode\u0026#39; ) item.connect(\u0026#39;activate\u0026#39;, self.launch_vscode, files) return [item] def get_background_items(self, *args): # 右键空白位置时的方法 file_ = args[-1] item = Nautilus.MenuItem( name=\u0026#39;VSCodeOpenBackground\u0026#39;, label=\u0026#39;Open in Code\u0026#39;, tip=\u0026#39;Opens the current directory in VSCode\u0026#39; ) item.connect(\u0026#39;activate\u0026#39;, self.launch_vscode, [file_]) return [item] 上面的 python 代码足够直观了。get_backgroud_items 和 get_file_items 返回一个菜单数组，而菜单如何创建和与具体的操作方法链接上面的示例已经足够说明。\n","permalink":"http://localhost:4449/posts/nautilus-right-click/","summary":"nautilus 是 GNOME 桌面环境默认的 GUI 文件管理器。本文介绍如何为 nautilus 添加自定义的右键菜单项。","title":"如何为 nautilus 配置右键菜单"},{"content":"","permalink":"http://localhost:4449/tags/","summary":"tags","title":"标签"},{"content":" 我，无畏并发。 《BanG Dream! Ave Mujica》（大嘘）\n零、一些基本的讨论 锁应当存放在大家共用的内存空间，总之不应该是栈。 一个好的锁应该提供正确的互斥、保障线程公平、性能优秀。 零、一些失败的想法 关中断：这很容易被滥用，导致系统接收不到中断信息；不适用于多处理器系统。 Peterson 算法：必须假设访存的原子性，但这一点现代硬件早就打破了。 int flag[2]; int turn; void init() { flag[0] = flag[1] = 0; turn = 0; } void lock() { flag[self] = 1; // 竖起自己的旗子 turn = 1 - self; // 让 turn 等于对面 // 我们假设对面此时也执行了这两句，turn 此时等于 self while((flag[1 - self] == 1) \u0026amp;\u0026amp; (turn == 1 - self)) ; // 因为对面改变了turn，那我们先执行了，对面先等着 // 先修改 turn 的才能跳出这个 while，也就是手快有手慢无 } void unlock() { flag[self] = 0; } 一、test-and-set 这种想法基于自旋锁（也就是只通过一个 flag 区分是否上锁），但是不依赖硬件显然不行，因为更精妙的 Peterson 都行不通。 x86 提供了与以下 C 代码类似的原子指令，硬件保证这个过程的原子性： // not code, but hardware implemented atomic test-and-set operation int TEST_AND_SET(int *old_ptr, int new) { int old = *old_ptr; *old_ptr = new; return old; } // 也就是把值改成新的，返回旧值 这样我们终于能够设计年轻人的第一把锁了：\n// this is C code!!! ","permalink":"http://localhost:4449/posts/os6-2/","summary":"作为无畏并发的基本手段，有必要复习一下设计锁的方法。","title":"操作系统复习·锁"},{"content":" 学而不思则罔，思而不学则殆。\n我们主要参考 sploitfun 先生的 Understanding glibc malloc 一文，对 malloc 的实现进行认真的学习和分析，最后形成了几张图解，比较全面地概括了相关的数据结构和算法。\n","permalink":"http://localhost:4449/posts/os6-1/","summary":"无论是操作系统内部还是应用程序，无论是单核 CPU 还是多核 CPU，堆分配都是操作系统实现和改良的核心话题之一。","title":"操作系统复习·堆分配"},{"content":"开发操作系统是我从小到大的梦想。但在追逐这个梦想的道路上我走了不少的弯路。\n初中的时候，我因为写 VBS 脚本装 B 认识了一位很好的朋友。我们一起讨论和学习 VBS，后来是 HTML，再后来是 VB 和 C#。那时候的我们相信，写一个操作系统是全天下最牛逼的事情。但就这点本事怎么可能写操作系统呢？我选择了用 PPT 来 “设计” “操作系统”，搞出一个 “Windows 13” 来。我的朋友选择用 C# 来模拟 Windows 的外观和基本功能，这样就看起来像是一个操作系统了。在这个 PPT 里，我通过 PowerPoint 内置的 VBA 写了一个记事本功能的“Word 2019”，那是我写的第一个程序。\n图 1 我用 PPT “设计” 的 “Windows 13.5” （微软请原谅我糟糕的美术知识）\n图 2 在另一个朋友制作的“手机”上搭载 “Windows 13 Phone”，那时的我可以很快画出 Win10 的 Hero 壁纸\n图 3 “也许 N 年后，Windows 13 系列会有后续，但那时，也许就不再是 PPT 了”\n高中的时候，我仍然在有限的空闲时间内继续空想一个操作系统。一方面，在闲暇时间，手边又没有电脑，我会手绘一些想到的“产品设计”；另一方面，我了解到有《30天自制操作系统》这本书，还在网上找了一些很有意思的教程，打算在有空闲时间时大干一场。\n图 4 我使用汇编语言写了第一个裸机应用程序 “Hello World”\n图 5 我那时还在着迷于所谓的“产品设计”\n可惜的是，那时候的空闲时间实在太少，我还把大部分时间用来开发一个在班级白板上使用的教学助手。等到有时间实践网上找到的操作系统教程时，却被汇编语言的难度和连接国际互联网的问题（那时不配置 apt 源在国内是用不成 apt 的。对于一个使用 Windows 很多年的爱好者，我在刚开始并没有找到学习 Ubuntu 的合理路径，被大量不熟悉的细节给围殴了。而且没有 Google 很多问题也没法完全搞清楚。）困扰了很久，最后还是放弃了。对那时的我，访问 Github 都得靠运气——据说早上九点是个好的时间。\n再后来，我成功得偿所愿进入计算机系学习。和操作系统相关的第一次尝试是数电实验课程。我那时仍然空想在我设计的 rv32ui 指令集的用 FPGA 模拟的 CPU 上运行自己写的操作系统——可是没有特权指令集，这怎么可能呢？最后，我仍然只实现了一个简陋的裸机终端。不过因为以往的这些执念，我没有组小组，而是一个人完成了从 CPU 设计到终端开发的全部工作——其实应该去 Github 找找裸机终端的代码的，那时候还是太年轻了。\n图 6 minTerminal 的架构图。那时的我很骄傲独立完成了这个项目\n现在的我，学习完了操作系统课程，认识到自己以前幼稚的探索确实错过了很多学习知识、实现梦想的机会。但蓦然回首，我发现我已经可以学习一个优秀的内核实现的全部代码了，我有信心掌握全部的细节。而且，还有《Operating Systems: Three Easy Pieces》这样优秀的教材。这比自己碰壁，在知乎上找“操作系统教程”有意义的多。\n好了，说了这么多废话，最后还是希望自己能坚持下来吧。\n","permalink":"http://localhost:4449/posts/os6-0/","summary":"本节内容和技术无关，纯属瞎唠叨。","title":"操作系统复习·前言"},{"content":"项目地址（配有使用方法）：https://github.com/HazeMa0/fly-hadoop2-workflow\n作为博客，还是整理一下这个过程中的困难吧。\n一、网络问题很烦人 首先，事实是：2024 年，中国大陆的主要高校和云服务商都关闭了 Docker Hub 的镜像源。但是百度仍有大量的帖子在建议更换镜像源以改善对 Docker Hub 的访问。\n我在我的 Windows 环境部署了代理。WSL2 理应继承代理设置。但是神奇的事情发生了：WSL2 我们可以顺利地 docker build，Windows 却不行。\n然后，我们做了以下事情试图让 Dockerfile 的 from 指令正常工作：\n设置 HTTP_PROXY 和 HTTPS_PROXY 环境变量； 注意！\nHTTPS_PROXY 对应的仍然是 http://localhost:1234，而不是 https！我是在发现环境变量使我的 VSCode 无法正常工作时才发现这个问题的；\n配置 Docker Engine 的配置文件： \u0026#34;proxies\u0026#34;: { \u0026#34;default\u0026#34;: { \u0026#34;httpProxy\u0026#34;: \u0026#34;http://127.0.0.1:9870\u0026#34;, \u0026#34;httpsProxy\u0026#34;: \u0026#34;http://127.0.0.1:9870\u0026#34;, \u0026#34;noProxy\u0026#34;: \u0026#34;localhost,127.0.0.1\u0026#34; } } 修改 ~/.docker/config.json（最后又删掉了） 在我没发现我把 HTTPS_PROXY 写成 https://\u0026hellip; 时，这三个修改都不起作用。然后，在一次神秘的 docker pull ... 后，突然就好起来了，我至今也没搞清楚到底是怎么回事。\n我们认识到，ping 命令走的是 ICMP 协议，对测试 http/socks5 的代理没有意义。 二、对 Docker 和 Dev Container 的错误理解 刚开始，我们在使用 Docker 运行和使用 Dev Container 作为开发环境上犹豫和摇摆了很长时间。我问了 AI 下面这一大段文字，可见我当时的烦躁。\n我现在陷入了一些混乱，需要你来拯救我。要写代码，首先要有开发环境。一般来说，这意味着编译器和解释器以及外部库和系统库的版本，还有代码构建工具的版本。这些东西在不同的开发项目中很容易冲突。然后我们运行起来了程序。然后希望交给测试测试。我没有在公司工作过，我不知道测试测试时需不需要源代码，还是只拿最终可执行程序进行测试。如果需要，那他也需要开发环境。然后经过修改，最后交付用户。用户不同软件之间的运行环境也可能冲突，一般来说，运行环境应该是开发环境的一个子集。容器要怎么终结这一系列混乱？\n好了，现在产生了问题。首先开发者要搭建一个叫做开发环境的玩意。把编译器/解释器/代码生成程序/外部库/系统库封装在容器里面是很好，问题是本地运行的IDE怎么和这些容器里面的玩意交互，从而支持语法高亮和其他功能呢？其次，我说了，运行环境往往是开发环境的子集，编译器对运行环境毫无必要。难道容器通过纵容这些冗余来换取分发效率吗？还有，为什么现实中面向普通用户的应用没有一个用docker分发呢？\n产生这些困惑的 Docker 相关问题是：\n以为代码的依赖都在容器里面，不希望手动把依赖拷到物理机恶心自己。虽然我们确实可以在容器里面援引相关的 jar，但更方便的方法是直接在本地通过 Maven 从中心仓库部署合适的依赖用于测试。 不了解容器挂载技术，以为我们必须手动把 jar 文件拷贝到容器测试。 不了解本地测试 Hadoop，以为所有类型的测试必须使用 hadoop jar 命令执行。实际上我们甚至可以不启动容器进行本地测试，完全本地开发。 区分不了镜像和容器。镜像是死的初始化状态，容器是基于镜像的可工作的实体。Dockerfile 产生镜像。 过早把自己摆到用户角度，认为开发环境对运行环境是冗余的（冗余了你改改 Dockerfile 不就行了吗，对刚开始的我来说改这玩意很困难，现在完全不是了） Dev Container 相关问题是：\n神圣化 Dev Container，以为其不会往容器里面部署 IDE 后端，从而产生了一系列矛盾； 以为 Dev Container 不能配置容器开放的端口。同时认识到，不能修改一个已经打开的容器的端口映射，这是为了简化容器运行状态故意为之的设计。 Dev Container 指定 entrypoint 不是在 postCreateCommand，也不是在 Dockerfile，只有通过 runArgs 指定才是正确的。 不知道为什么，让 Dev Container 执行我的脚本时不能正确识别 echo 的 -e 参数，而是将其作为文本打印。最后我们换用了 printf 命令。 三、一些 linux 知识 Hadoop 环境初始化脚本需要 ssh 连接，就会产生下面这种需要手动确认的麻烦问题： yes：The authenticity of host \u0026#39;localhost (::1)\u0026#39; can\u0026#39;t be established. ECDSA key fingerprint is SHA256:**********.\rAre you sure you want to continue connecting (yes/no)? 我们希望初始化脚本作为 Docker 的 1 号进程，当然不希望这种需要手工确认的东西出现。我们最终使用以下脚本解决：\ntouch ~/.ssh/config printf \u0026#34;Host *\\n\\tStrictHostKeyChecking no\\n\\tUserKnownHostsFile /dev/null\\n\u0026#34; \u0026gt; ~/.ssh/config 该死的 \\r\\n 在 Windows，git 默认会把 \\n 替换成 \\r\\n。这最后导致我的脚本 push 再 clone 后竟然无法运行了。最后一行命令解决问题： git config --global core.autocrlf false 有趣的事实：JDK 1.x == JDK x 四、该死的讲义问题 讲义给出的一些命令根本是错误的。\n讲义没有细说应该怎么修改 Hadoop 的若干 xml，百度也在画蛇添足。只有官方文档才是可靠的。\n讲义没告诉我 start-all.sh 的正确位置，让我无法正确配置 PATH。\n五、鸣谢 感谢 DeepSeek 和 ChatGPT 耐心地听我抱怨和提出问题。没有任何一个人类受得了这么多怨气和不满。\n感谢官方的 Hadoop 安装教程。\n感谢 Google。珍爱生命，拒绝百度。\n","permalink":"http://localhost:4449/posts/fly-hadoop2-workflow/","summary":"项目地址：https://github.com/HazeMa0/fly-hadoop2-workflow。借助 Docker 和 Dev Container，舒适地开发老旧框架的程序。本文阐述了这个项目中遇到的困难。","title":"fly-hadoop2-workflow：让编写 hadoop 2.7 应用的效率飞起来"},{"content":" 相关软件（不限版本）\nnautilus 刚装好 Ubuntu，我们在文件管理器的右键菜单里面找不到新建文件的选项，这确实很让人匪夷所思。\n实际上，我们只需要在 ~/Templates 新建一个模板就好。\n$ cd ~/Templates $ touch `TXT.txt` $ touch `Markdown.md` 当然这个方案并不完美，就是并没有在新建文件后自动处于重命名状态的功能。\n","permalink":"http://localhost:4449/posts/nautilus-new-file/","summary":"为 nautilus 添加新建选项的菜单并不困难。因为 ~/Templates 就是专门为之服务的。","title":"如何为 nautilus 右键菜单添加新建文件选项"},{"content":" 相关软件版本\nUbuntu 22.04 及以上 nautilus 是 GNOME 桌面环境默认的 GUI 文件管理器。\n本来其实没想到这样一个简单的任务会引起一些麻烦。把我处理这个麻烦的过程记下来吧。\n首先，我们百度搜索这个问题，从一些相当新的帖子获得的解决方案是安装 nautilus-actions。但意外的是，在 Ubuntu 22.04 中，这个包被移除了。\n我们转战谷歌，找到了这篇帖子，告诉我们这个软件因为缺少更新已经被上游的 gnome 存档了。我们也并不想使用已经被废弃的软件，那就去找替代方案吧——我相信不可能没有提供。\n意外发现：gnome 原来用 gitlab 管理项目，有趣。\n翻译者没有兴趣维护这个软件：\u0026ldquo;Sorry, but if there\u0026rsquo;s no contributions for several years, we\u0026rsquo;re not going to keep it active. It wastes the efforts of our translators. Feel free to fork and maintain it somewhere else if you like (it\u0026rsquo;s open source, after all).\u0026rdquo;\n另一篇帖子 指出了两个替代方案：一个是我在以前使用过的 Nautilus Scripts，最终效果是在右键菜单里面显示一个 Scripts 子菜单，里面有我们写好的脚本作为选项。这种方法不够优雅，我们希望显示在主右键菜单里面；另一个是 nautilus-python，出于对 python 的好感我们最终选择这个方案。\n问题又来了，在 Ubuntu 安装 nautilus-python，也没有这个包。经过检查，一篇帖子 指出其在 Ubuntu 源的名称是 python3-nautilus，这可能是因为一些误解产生的问题。\n现在我们学习写 python 代码来实现 nautilus-python 的扩展。参考资源：官方示例、linuxconfig.org 的教程。我们将写好的 python 文件保存到 ~/.local/share/nautilus-python/extensions/ 即可，然后重启 nautilus 即可。\n先看下面的示例，其为 VSCode 打开文件夹和文件提供了右键菜单（使用命令 wget -qO- https://raw.githubusercontent.com/harry-cpp/code-nautilus/master/install.sh | bash 以快速安装，我对代码做了一些简化，原本的源代码请参考相应的 GitHub 仓库）：\nfrom gi.repository import Nautilus, GObject from subprocess import call import os class VSCodeExtension(GObject.GObject, Nautilus.MenuProvider): # python 支持多重继承 def launch_vscode(self, menu, files): # 参数是 self, menu, files，注意不要修改 safepaths = \u0026#39;\u0026#39; args = \u0026#39;\u0026#39; for file in files: filepath = file.get_location().get_path() safepaths += \u0026#39;\u0026#34;\u0026#39; + filepath + \u0026#39;\u0026#34; \u0026#39; if os.path.isdir(filepath) and os.path.exists(filepath): args = \u0026#39;--new-window \u0026#39; call(\u0026#39;code \u0026#39; + args + safepaths + \u0026#39;\u0026amp;\u0026#39;, shell=True) def get_file_items(self, *args): # 右键文件/文件夹时对应的方法 files = args[-1] item = Nautilus.MenuItem( name=\u0026#39;VSCodeOpen\u0026#39;, label=\u0026#39;Open in Code\u0026#39;, tip=\u0026#39;Opens the selected files with VSCode\u0026#39; ) item.connect(\u0026#39;activate\u0026#39;, self.launch_vscode, files) return [item] def get_background_items(self, *args): # 右键空白位置时的方法 file_ = args[-1] item = Nautilus.MenuItem( name=\u0026#39;VSCodeOpenBackground\u0026#39;, label=\u0026#39;Open in Code\u0026#39;, tip=\u0026#39;Opens the current directory in VSCode\u0026#39; ) item.connect(\u0026#39;activate\u0026#39;, self.launch_vscode, [file_]) return [item] 上面的 python 代码足够直观了。get_backgroud_items 和 get_file_items 返回一个菜单数组，而菜单如何创建和与具体的操作方法链接上面的示例已经足够说明。\n","permalink":"http://localhost:4449/posts/nautilus-right-click/","summary":"nautilus 是 GNOME 桌面环境默认的 GUI 文件管理器。本文介绍如何为 nautilus 添加自定义的右键菜单项。","title":"如何为 nautilus 配置右键菜单"},{"content":"","permalink":"http://localhost:4449/tags/","summary":"tags","title":"标签"},{"content":" 我，无畏并发。 《BanG Dream! Ave Mujica》（大嘘）\n零、一些基本的讨论 锁应当存放在大家共用的内存空间，总之不应该是栈。 一个好的锁应该提供正确的互斥、保障线程公平、性能优秀。 零、一些失败的想法 关中断：这很容易被滥用，导致系统接收不到中断信息；不适用于多处理器系统。 Peterson 算法：必须假设访存的原子性，但这一点现代硬件早就打破了。 int flag[2]; int turn; void init() { flag[0] = flag[1] = 0; turn = 0; } void lock() { flag[self] = 1; // 竖起自己的旗子 turn = 1 - self; // 让 turn 等于对面 // 我们假设对面此时也执行了这两句，turn 此时等于 self while((flag[1 - self] == 1) \u0026amp;\u0026amp; (turn == 1 - self)) ; // 因为对面改变了turn，那我们先执行了，对面先等着 // 先修改 turn 的才能跳出这个 while，也就是手快有手慢无 } void unlock() { flag[self] = 0; } 一、test-and-set 这种想法基于自旋锁（也就是只通过一个 flag 区分是否上锁），但是不依赖硬件显然不行，因为更精妙的 Peterson 都行不通。 x86 提供了与以下 C 代码类似的原子指令，硬件保证这个过程的原子性： // not code, but hardware implemented atomic test-and-set operation int TEST_AND_SET(int *old_ptr, int new) { int old = *old_ptr; *old_ptr = new; return old; } // 也就是把值改成新的，返回旧值 这样我们终于能够设计年轻人的第一把锁了：\n// this is C code!!! void init(lock *lock) { lock-\u0026gt;flag = 0; } void lock(lock *lock) { while (TestAndSet(\u0026amp;lock-\u0026gt;flag, 1) == 1) ; } void unlock(lock *lock) { lock-\u0026gt;flag = 0; } // 多么轻松愉快！ ","permalink":"http://localhost:4449/posts/os6-2/","summary":"作为无畏并发的基本手段，有必要复习一下设计锁的方法。","title":"操作系统复习·锁"},{"content":" 学而不思则罔，思而不学则殆。\n我们主要参考 sploitfun 先生的 Understanding glibc malloc 一文，对 malloc 的实现进行认真的学习和分析，最后形成了几张图解，比较全面地概括了相关的数据结构和算法。\n","permalink":"http://localhost:4449/posts/os6-1/","summary":"无论是操作系统内部还是应用程序，无论是单核 CPU 还是多核 CPU，堆分配都是操作系统实现和改良的核心话题之一。","title":"操作系统复习·堆分配"},{"content":"开发操作系统是我从小到大的梦想。但在追逐这个梦想的道路上我走了不少的弯路。\n初中的时候，我因为写 VBS 脚本装 B 认识了一位很好的朋友。我们一起讨论和学习 VBS，后来是 HTML，再后来是 VB 和 C#。那时候的我们相信，写一个操作系统是全天下最牛逼的事情。但就这点本事怎么可能写操作系统呢？我选择了用 PPT 来 “设计” “操作系统”，搞出一个 “Windows 13” 来。我的朋友选择用 C# 来模拟 Windows 的外观和基本功能，这样就看起来像是一个操作系统了。在这个 PPT 里，我通过 PowerPoint 内置的 VBA 写了一个记事本功能的“Word 2019”，那是我写的第一个程序。\n图 1 我用 PPT “设计” 的 “Windows 13.5” （微软请原谅我糟糕的美术知识）\n图 2 在另一个朋友制作的“手机”上搭载 “Windows 13 Phone”，那时的我可以很快画出 Win10 的 Hero 壁纸\n图 3 “也许 N 年后，Windows 13 系列会有后续，但那时，也许就不再是 PPT 了”\n高中的时候，我仍然在有限的空闲时间内继续空想一个操作系统。一方面，在闲暇时间，手边又没有电脑，我会手绘一些想到的“产品设计”；另一方面，我了解到有《30天自制操作系统》这本书，还在网上找了一些很有意思的教程，打算在有空闲时间时大干一场。\n图 4 我使用汇编语言写了第一个裸机应用程序 “Hello World”\n图 5 我那时还在着迷于所谓的“产品设计”\n可惜的是，那时候的空闲时间实在太少，我还把大部分时间用来开发一个在班级白板上使用的教学助手。等到有时间实践网上找到的操作系统教程时，却被汇编语言的难度和连接国际互联网的问题（那时不配置 apt 源在国内是用不成 apt 的。对于一个使用 Windows 很多年的爱好者，我在刚开始并没有找到学习 Ubuntu 的合理路径，被大量不熟悉的细节给围殴了。而且没有 Google 很多问题也没法完全搞清楚。）困扰了很久，最后还是放弃了。对那时的我，访问 Github 都得靠运气——据说早上九点是个好的时间。\n再后来，我成功得偿所愿进入计算机系学习。和操作系统相关的第一次尝试是数电实验课程。我那时仍然空想在我设计的 rv32ui 指令集的用 FPGA 模拟的 CPU 上运行自己写的操作系统——可是没有特权指令集，这怎么可能呢？最后，我仍然只实现了一个简陋的裸机终端。不过因为以往的这些执念，我没有组小组，而是一个人完成了从 CPU 设计到终端开发的全部工作——其实应该去 Github 找找裸机终端的代码的，那时候还是太年轻了。\n图 6 minTerminal 的架构图。那时的我很骄傲独立完成了这个项目\n现在的我，学习完了操作系统课程，认识到自己以前幼稚的探索确实错过了很多学习知识、实现梦想的机会。但蓦然回首，我发现我已经可以学习一个优秀的内核实现的全部代码了，我有信心掌握全部的细节。而且，还有《Operating Systems: Three Easy Pieces》这样优秀的教材。这比自己碰壁，在知乎上找“操作系统教程”有意义的多。\n好了，说了这么多废话，最后还是希望自己能坚持下来吧。\n","permalink":"http://localhost:4449/posts/os6-0/","summary":"本节内容和技术无关，纯属瞎唠叨。","title":"操作系统复习·前言"},{"content":"项目地址（配有使用方法）：https://github.com/HazeMa0/fly-hadoop2-workflow\n作为博客，还是整理一下这个过程中的困难吧。\n一、网络问题很烦人 首先，事实是：2024 年，中国大陆的主要高校和云服务商都关闭了 Docker Hub 的镜像源。但是百度仍有大量的帖子在建议更换镜像源以改善对 Docker Hub 的访问。\n我在我的 Windows 环境部署了代理。WSL2 理应继承代理设置。但是神奇的事情发生了：WSL2 我们可以顺利地 docker build，Windows 却不行。\n然后，我们做了以下事情试图让 Dockerfile 的 from 指令正常工作：\n设置 HTTP_PROXY 和 HTTPS_PROXY 环境变量； 注意！\nHTTPS_PROXY 对应的仍然是 http://localhost:1234，而不是 https！我是在发现环境变量使我的 VSCode 无法正常工作时才发现这个问题的；\n配置 Docker Engine 的配置文件： \u0026#34;proxies\u0026#34;: { \u0026#34;default\u0026#34;: { \u0026#34;httpProxy\u0026#34;: \u0026#34;http://127.0.0.1:9870\u0026#34;, \u0026#34;httpsProxy\u0026#34;: \u0026#34;http://127.0.0.1:9870\u0026#34;, \u0026#34;noProxy\u0026#34;: \u0026#34;localhost,127.0.0.1\u0026#34; } } 修改 ~/.docker/config.json（最后又删掉了） 在我没发现我把 HTTPS_PROXY 写成 https://\u0026hellip; 时，这三个修改都不起作用。然后，在一次神秘的 docker pull ... 后，突然就好起来了，我至今也没搞清楚到底是怎么回事。\n我们认识到，ping 命令走的是 ICMP 协议，对测试 http/socks5 的代理没有意义。 二、对 Docker 和 Dev Container 的错误理解 刚开始，我们在使用 Docker 运行和使用 Dev Container 作为开发环境上犹豫和摇摆了很长时间。我问了 AI 下面这一大段文字，可见我当时的烦躁。\n我现在陷入了一些混乱，需要你来拯救我。要写代码，首先要有开发环境。一般来说，这意味着编译器和解释器以及外部库和系统库的版本，还有代码构建工具的版本。这些东西在不同的开发项目中很容易冲突。然后我们运行起来了程序。然后希望交给测试测试。我没有在公司工作过，我不知道测试测试时需不需要源代码，还是只拿最终可执行程序进行测试。如果需要，那他也需要开发环境。然后经过修改，最后交付用户。用户不同软件之间的运行环境也可能冲突，一般来说，运行环境应该是开发环境的一个子集。容器要怎么终结这一系列混乱？\n好了，现在产生了问题。首先开发者要搭建一个叫做开发环境的玩意。把编译器/解释器/代码生成程序/外部库/系统库封装在容器里面是很好，问题是本地运行的IDE怎么和这些容器里面的玩意交互，从而支持语法高亮和其他功能呢？其次，我说了，运行环境往往是开发环境的子集，编译器对运行环境毫无必要。难道容器通过纵容这些冗余来换取分发效率吗？还有，为什么现实中面向普通用户的应用没有一个用docker分发呢？\n产生这些困惑的 Docker 相关问题是：\n以为代码的依赖都在容器里面，不希望手动把依赖拷到物理机恶心自己。虽然我们确实可以在容器里面援引相关的 jar，但更方便的方法是直接在本地通过 Maven 从中心仓库部署合适的依赖用于测试。 不了解容器挂载技术，以为我们必须手动把 jar 文件拷贝到容器测试。 不了解本地测试 Hadoop，以为所有类型的测试必须使用 hadoop jar 命令执行。实际上我们甚至可以不启动容器进行本地测试，完全本地开发。 区分不了镜像和容器。镜像是死的初始化状态，容器是基于镜像的可工作的实体。Dockerfile 产生镜像。 过早把自己摆到用户角度，认为开发环境对运行环境是冗余的（冗余了你改改 Dockerfile 不就行了吗，对刚开始的我来说改这玩意很困难，现在完全不是了） Dev Container 相关问题是：\n神圣化 Dev Container，以为其不会往容器里面部署 IDE 后端，从而产生了一系列矛盾； 以为 Dev Container 不能配置容器开放的端口。同时认识到，不能修改一个已经打开的容器的端口映射，这是为了简化容器运行状态故意为之的设计。 Dev Container 指定 entrypoint 不是在 postCreateCommand，也不是在 Dockerfile，只有通过 runArgs 指定才是正确的。 不知道为什么，让 Dev Container 执行我的脚本时不能正确识别 echo 的 -e 参数，而是将其作为文本打印。最后我们换用了 printf 命令。 三、一些 linux 知识 Hadoop 环境初始化脚本需要 ssh 连接，就会产生下面这种需要手动确认的麻烦问题： yes：The authenticity of host \u0026#39;localhost (::1)\u0026#39; can\u0026#39;t be established. ECDSA key fingerprint is SHA256:**********.\rAre you sure you want to continue connecting (yes/no)? 我们希望初始化脚本作为 Docker 的 1 号进程，当然不希望这种需要手工确认的东西出现。我们最终使用以下脚本解决：\ntouch ~/.ssh/config printf \u0026#34;Host *\\n\\tStrictHostKeyChecking no\\n\\tUserKnownHostsFile /dev/null\\n\u0026#34; \u0026gt; ~/.ssh/config 该死的 \\r\\n 在 Windows，git 默认会把 \\n 替换成 \\r\\n。这最后导致我的脚本 push 再 clone 后竟然无法运行了。最后一行命令解决问题： git config --global core.autocrlf false 有趣的事实：JDK 1.x == JDK x 四、该死的讲义问题 讲义给出的一些命令根本是错误的。\n讲义没有细说应该怎么修改 Hadoop 的若干 xml，百度也在画蛇添足。只有官方文档才是可靠的。\n讲义没告诉我 start-all.sh 的正确位置，让我无法正确配置 PATH。\n五、鸣谢 感谢 DeepSeek 和 ChatGPT 耐心地听我抱怨和提出问题。没有任何一个人类受得了这么多怨气和不满。\n感谢官方的 Hadoop 安装教程。\n感谢 Google。珍爱生命，拒绝百度。\n","permalink":"http://localhost:4449/posts/fly-hadoop2-workflow/","summary":"项目地址：https://github.com/HazeMa0/fly-hadoop2-workflow。借助 Docker 和 Dev Container，舒适地开发老旧框架的程序。本文阐述了这个项目中遇到的困难。","title":"fly-hadoop2-workflow：让编写 hadoop 2.7 应用的效率飞起来"},{"content":" 相关软件（不限版本）\nnautilus 刚装好 Ubuntu，我们在文件管理器的右键菜单里面找不到新建文件的选项，这确实很让人匪夷所思。\n实际上，我们只需要在 ~/Templates 新建一个模板就好。\n$ cd ~/Templates $ touch `TXT.txt` $ touch `Markdown.md` 当然这个方案并不完美，就是并没有在新建文件后自动处于重命名状态的功能。\n","permalink":"http://localhost:4449/posts/nautilus-new-file/","summary":"为 nautilus 添加新建选项的菜单并不困难。因为 ~/Templates 就是专门为之服务的。","title":"如何为 nautilus 右键菜单添加新建文件选项"},{"content":" 相关软件版本\nUbuntu 22.04 及以上 nautilus 是 GNOME 桌面环境默认的 GUI 文件管理器。\n本来其实没想到这样一个简单的任务会引起一些麻烦。把我处理这个麻烦的过程记下来吧。\n首先，我们百度搜索这个问题，从一些相当新的帖子获得的解决方案是安装 nautilus-actions。但意外的是，在 Ubuntu 22.04 中，这个包被移除了。\n我们转战谷歌，找到了这篇帖子，告诉我们这个软件因为缺少更新已经被上游的 gnome 存档了。我们也并不想使用已经被废弃的软件，那就去找替代方案吧——我相信不可能没有提供。\n意外发现：gnome 原来用 gitlab 管理项目，有趣。\n翻译者没有兴趣维护这个软件：\u0026ldquo;Sorry, but if there\u0026rsquo;s no contributions for several years, we\u0026rsquo;re not going to keep it active. It wastes the efforts of our translators. Feel free to fork and maintain it somewhere else if you like (it\u0026rsquo;s open source, after all).\u0026rdquo;\n另一篇帖子 指出了两个替代方案：一个是我在以前使用过的 Nautilus Scripts，最终效果是在右键菜单里面显示一个 Scripts 子菜单，里面有我们写好的脚本作为选项。这种方法不够优雅，我们希望显示在主右键菜单里面；另一个是 nautilus-python，出于对 python 的好感我们最终选择这个方案。\n问题又来了，在 Ubuntu 安装 nautilus-python，也没有这个包。经过检查，一篇帖子 指出其在 Ubuntu 源的名称是 python3-nautilus，这可能是因为一些误解产生的问题。\n现在我们学习写 python 代码来实现 nautilus-python 的扩展。参考资源：官方示例、linuxconfig.org 的教程。我们将写好的 python 文件保存到 ~/.local/share/nautilus-python/extensions/ 即可，然后重启 nautilus 即可。\n先看下面的示例，其为 VSCode 打开文件夹和文件提供了右键菜单（使用命令 wget -qO- https://raw.githubusercontent.com/harry-cpp/code-nautilus/master/install.sh | bash 以快速安装，我对代码做了一些简化，原本的源代码请参考相应的 GitHub 仓库）：\nfrom gi.repository import Nautilus, GObject from subprocess import call import os class VSCodeExtension(GObject.GObject, Nautilus.MenuProvider): # python 支持多重继承 def launch_vscode(self, menu, files): # 参数是 self, menu, files，注意不要修改 safepaths = \u0026#39;\u0026#39; args = \u0026#39;\u0026#39; for file in files: filepath = file.get_location().get_path() safepaths += \u0026#39;\u0026#34;\u0026#39; + filepath + \u0026#39;\u0026#34; \u0026#39; if os.path.isdir(filepath) and os.path.exists(filepath): args = \u0026#39;--new-window \u0026#39; call(\u0026#39;code \u0026#39; + args + safepaths + \u0026#39;\u0026amp;\u0026#39;, shell=True) def get_file_items(self, *args): # 右键文件/文件夹时对应的方法 files = args[-1] item = Nautilus.MenuItem( name=\u0026#39;VSCodeOpen\u0026#39;, label=\u0026#39;Open in Code\u0026#39;, tip=\u0026#39;Opens the selected files with VSCode\u0026#39; ) item.connect(\u0026#39;activate\u0026#39;, self.launch_vscode, files) return [item] def get_background_items(self, *args): # 右键空白位置时的方法 file_ = args[-1] item = Nautilus.MenuItem( name=\u0026#39;VSCodeOpenBackground\u0026#39;, label=\u0026#39;Open in Code\u0026#39;, tip=\u0026#39;Opens the current directory in VSCode\u0026#39; ) item.connect(\u0026#39;activate\u0026#39;, self.launch_vscode, [file_]) return [item] 上面的 python 代码足够直观了。get_backgroud_items 和 get_file_items 返回一个菜单数组，而菜单如何创建和与具体的操作方法链接上面的示例已经足够说明。\n","permalink":"http://localhost:4449/posts/nautilus-right-click/","summary":"nautilus 是 GNOME 桌面环境默认的 GUI 文件管理器。本文介绍如何为 nautilus 添加自定义的右键菜单项。","title":"如何为 nautilus 配置右键菜单"},{"content":"","permalink":"http://localhost:4449/tags/","summary":"tags","title":"标签"},{"content":" 我，无畏并发。 《BanG Dream! Ave Mujica》（大嘘）\n零、一些基本的讨论 锁应当存放在大家共用的内存空间，总之不应该是栈。 一个好的锁应该提供正确的互斥、保障线程公平、性能优秀。 零、一些失败的想法 关中断：这很容易被滥用，导致系统接收不到中断信息；不适用于多处理器系统。 Peterson 算法：必须假设访存的原子性，但这一点现代硬件早就打破了。 int flag[2]; int turn; void init() { flag[0] = flag[1] = 0; turn = 0; } void lock() { flag[self] = 1; // 竖起自己的旗子 turn = 1 - self; // 让 turn 等于对面 // 我们假设对面此时也执行了这两句，turn 此时等于 self while((flag[1 - self] == 1) \u0026amp;\u0026amp; (turn == 1 - self)) ; // 因为对面改变了turn，那我们先执行了，对面先等着 // 先修改 turn 的才能跳出这个 while，也就是手快有手慢无 } void unlock() { flag[self] = 0; } 一、test-and-set 这种想法基于自旋锁（也就是只通过一个 flag 区分是否上锁），但是不依赖硬件显然不行，因为更精妙的 Peterson 都行不通。 x86 提供了与以下 C 代码类似的原子指令，硬件保证这个过程的原子性： // not code, but hardware implemented atomic test-and-set operation int TEST_AND_SET(int *old_ptr, int new) { int old = *old_ptr; *old_ptr = new; return old; } // 也就是把值改成新的，返回旧值 这样我们终于能够设计年轻人的第一把锁了：\n// this is C code!!! void init(lock *lock) { lock-\u0026gt;flag = 0; } void lock(lock *lock) { while (TestAndSet(\u0026amp;lock-\u0026gt;flag, 1) == 1) ; } void unlock(lock *lock) { lock-\u0026gt;flag = 0; } // 多么轻松愉快！ ","permalink":"http://localhost:4449/posts/os6-2/","summary":"作为无畏并发的基本手段，有必要复习一下设计锁的方法。","title":"操作系统复习·锁"},{"content":" 学而不思则罔，思而不学则殆。\n我们主要参考 sploitfun 先生的 Understanding glibc malloc 一文，对 malloc 的实现进行认真的学习和分析，最后形成了几张图解，比较全面地概括了相关的数据结构和算法。\n","permalink":"http://localhost:4449/posts/os6-1/","summary":"无论是操作系统内部还是应用程序，无论是单核 CPU 还是多核 CPU，堆分配都是操作系统实现和改良的核心话题之一。","title":"操作系统复习·堆分配"},{"content":"开发操作系统是我从小到大的梦想。但在追逐这个梦想的道路上我走了不少的弯路。\n初中的时候，我因为写 VBS 脚本装 B 认识了一位很好的朋友。我们一起讨论和学习 VBS，后来是 HTML，再后来是 VB 和 C#。那时候的我们相信，写一个操作系统是全天下最牛逼的事情。但就这点本事怎么可能写操作系统呢？我选择了用 PPT 来 “设计” “操作系统”，搞出一个 “Windows 13” 来。我的朋友选择用 C# 来模拟 Windows 的外观和基本功能，这样就看起来像是一个操作系统了。在这个 PPT 里，我通过 PowerPoint 内置的 VBA 写了一个记事本功能的“Word 2019”，那是我写的第一个程序。\n图 1 我用 PPT “设计” 的 “Windows 13.5” （微软请原谅我糟糕的美术知识）\n图 2 在另一个朋友制作的“手机”上搭载 “Windows 13 Phone”，那时的我可以很快画出 Win10 的 Hero 壁纸\n图 3 “也许 N 年后，Windows 13 系列会有后续，但那时，也许就不再是 PPT 了”\n高中的时候，我仍然在有限的空闲时间内继续空想一个操作系统。一方面，在闲暇时间，手边又没有电脑，我会手绘一些想到的“产品设计”；另一方面，我了解到有《30天自制操作系统》这本书，还在网上找了一些很有意思的教程，打算在有空闲时间时大干一场。\n图 4 我使用汇编语言写了第一个裸机应用程序 “Hello World”\n图 5 我那时还在着迷于所谓的“产品设计”\n可惜的是，那时候的空闲时间实在太少，我还把大部分时间用来开发一个在班级白板上使用的教学助手。等到有时间实践网上找到的操作系统教程时，却被汇编语言的难度和连接国际互联网的问题（那时不配置 apt 源在国内是用不成 apt 的。对于一个使用 Windows 很多年的爱好者，我在刚开始并没有找到学习 Ubuntu 的合理路径，被大量不熟悉的细节给围殴了。而且没有 Google 很多问题也没法完全搞清楚。）困扰了很久，最后还是放弃了。对那时的我，访问 Github 都得靠运气——据说早上九点是个好的时间。\n再后来，我成功得偿所愿进入计算机系学习。和操作系统相关的第一次尝试是数电实验课程。我那时仍然空想在我设计的 rv32ui 指令集的用 FPGA 模拟的 CPU 上运行自己写的操作系统——可是没有特权指令集，这怎么可能呢？最后，我仍然只实现了一个简陋的裸机终端。不过因为以往的这些执念，我没有组小组，而是一个人完成了从 CPU 设计到终端开发的全部工作——其实应该去 Github 找找裸机终端的代码的，那时候还是太年轻了。\n图 6 minTerminal 的架构图。那时的我很骄傲独立完成了这个项目\n现在的我，学习完了操作系统课程，认识到自己以前幼稚的探索确实错过了很多学习知识、实现梦想的机会。但蓦然回首，我发现我已经可以学习一个优秀的内核实现的全部代码了，我有信心掌握全部的细节。而且，还有《Operating Systems: Three Easy Pieces》这样优秀的教材。这比自己碰壁，在知乎上找“操作系统教程”有意义的多。\n好了，说了这么多废话，最后还是希望自己能坚持下来吧。\n","permalink":"http://localhost:4449/posts/os6-0/","summary":"本节内容和技术无关，纯属瞎唠叨。","title":"操作系统复习·前言"},{"content":"项目地址（配有使用方法）：https://github.com/HazeMa0/fly-hadoop2-workflow\n作为博客，还是整理一下这个过程中的困难吧。\n一、网络问题很烦人 首先，事实是：2024 年，中国大陆的主要高校和云服务商都关闭了 Docker Hub 的镜像源。但是百度仍有大量的帖子在建议更换镜像源以改善对 Docker Hub 的访问。\n我在我的 Windows 环境部署了代理。WSL2 理应继承代理设置。但是神奇的事情发生了：WSL2 我们可以顺利地 docker build，Windows 却不行。\n然后，我们做了以下事情试图让 Dockerfile 的 from 指令正常工作：\n设置 HTTP_PROXY 和 HTTPS_PROXY 环境变量； 注意！\nHTTPS_PROXY 对应的仍然是 http://localhost:1234，而不是 https！我是在发现环境变量使我的 VSCode 无法正常工作时才发现这个问题的；\n配置 Docker Engine 的配置文件： \u0026#34;proxies\u0026#34;: { \u0026#34;default\u0026#34;: { \u0026#34;httpProxy\u0026#34;: \u0026#34;http://127.0.0.1:9870\u0026#34;, \u0026#34;httpsProxy\u0026#34;: \u0026#34;http://127.0.0.1:9870\u0026#34;, \u0026#34;noProxy\u0026#34;: \u0026#34;localhost,127.0.0.1\u0026#34; } } 修改 ~/.docker/config.json（最后又删掉了） 在我没发现我把 HTTPS_PROXY 写成 https://\u0026hellip; 时，这三个修改都不起作用。然后，在一次神秘的 docker pull ... 后，突然就好起来了，我至今也没搞清楚到底是怎么回事。\n我们认识到，ping 命令走的是 ICMP 协议，对测试 http/socks5 的代理没有意义。 二、对 Docker 和 Dev Container 的错误理解 刚开始，我们在使用 Docker 运行和使用 Dev Container 作为开发环境上犹豫和摇摆了很长时间。我问了 AI 下面这一大段文字，可见我当时的烦躁。\n我现在陷入了一些混乱，需要你来拯救我。要写代码，首先要有开发环境。一般来说，这意味着编译器和解释器以及外部库和系统库的版本，还有代码构建工具的版本。这些东西在不同的开发项目中很容易冲突。然后我们运行起来了程序。然后希望交给测试测试。我没有在公司工作过，我不知道测试测试时需不需要源代码，还是只拿最终可执行程序进行测试。如果需要，那他也需要开发环境。然后经过修改，最后交付用户。用户不同软件之间的运行环境也可能冲突，一般来说，运行环境应该是开发环境的一个子集。容器要怎么终结这一系列混乱？\n好了，现在产生了问题。首先开发者要搭建一个叫做开发环境的玩意。把编译器/解释器/代码生成程序/外部库/系统库封装在容器里面是很好，问题是本地运行的IDE怎么和这些容器里面的玩意交互，从而支持语法高亮和其他功能呢？其次，我说了，运行环境往往是开发环境的子集，编译器对运行环境毫无必要。难道容器通过纵容这些冗余来换取分发效率吗？还有，为什么现实中面向普通用户的应用没有一个用docker分发呢？\n产生这些困惑的 Docker 相关问题是：\n以为代码的依赖都在容器里面，不希望手动把依赖拷到物理机恶心自己。虽然我们确实可以在容器里面援引相关的 jar，但更方便的方法是直接在本地通过 Maven 从中心仓库部署合适的依赖用于测试。 不了解容器挂载技术，以为我们必须手动把 jar 文件拷贝到容器测试。 不了解本地测试 Hadoop，以为所有类型的测试必须使用 hadoop jar 命令执行。实际上我们甚至可以不启动容器进行本地测试，完全本地开发。 区分不了镜像和容器。镜像是死的初始化状态，容器是基于镜像的可工作的实体。Dockerfile 产生镜像。 过早把自己摆到用户角度，认为开发环境对运行环境是冗余的（冗余了你改改 Dockerfile 不就行了吗，对刚开始的我来说改这玩意很困难，现在完全不是了） Dev Container 相关问题是：\n神圣化 Dev Container，以为其不会往容器里面部署 IDE 后端，从而产生了一系列矛盾； 以为 Dev Container 不能配置容器开放的端口。同时认识到，不能修改一个已经打开的容器的端口映射，这是为了简化容器运行状态故意为之的设计。 Dev Container 指定 entrypoint 不是在 postCreateCommand，也不是在 Dockerfile，只有通过 runArgs 指定才是正确的。 不知道为什么，让 Dev Container 执行我的脚本时不能正确识别 echo 的 -e 参数，而是将其作为文本打印。最后我们换用了 printf 命令。 三、一些 linux 知识 Hadoop 环境初始化脚本需要 ssh 连接，就会产生下面这种需要手动确认的麻烦问题： yes：The authenticity of host \u0026#39;localhost (::1)\u0026#39; can\u0026#39;t be established. ECDSA key fingerprint is SHA256:**********.\rAre you sure you want to continue connecting (yes/no)? 我们希望初始化脚本作为 Docker 的 1 号进程，当然不希望这种需要手工确认的东西出现。我们最终使用以下脚本解决：\ntouch ~/.ssh/config printf \u0026#34;Host *\\n\\tStrictHostKeyChecking no\\n\\tUserKnownHostsFile /dev/null\\n\u0026#34; \u0026gt; ~/.ssh/config 该死的 \\r\\n 在 Windows，git 默认会把 \\n 替换成 \\r\\n。这最后导致我的脚本 push 再 clone 后竟然无法运行了。最后一行命令解决问题： git config --global core.autocrlf false 有趣的事实：JDK 1.x == JDK x 四、该死的讲义问题 讲义给出的一些命令根本是错误的。\n讲义没有细说应该怎么修改 Hadoop 的若干 xml，百度也在画蛇添足。只有官方文档才是可靠的。\n讲义没告诉我 start-all.sh 的正确位置，让我无法正确配置 PATH。\n五、鸣谢 感谢 DeepSeek 和 ChatGPT 耐心地听我抱怨和提出问题。没有任何一个人类受得了这么多怨气和不满。\n感谢官方的 Hadoop 安装教程。\n感谢 Google。珍爱生命，拒绝百度。\n","permalink":"http://localhost:4449/posts/fly-hadoop2-workflow/","summary":"项目地址：https://github.com/HazeMa0/fly-hadoop2-workflow。借助 Docker 和 Dev Container，舒适地开发老旧框架的程序。本文阐述了这个项目中遇到的困难。","title":"fly-hadoop2-workflow：让编写 hadoop 2.7 应用的效率飞起来"},{"content":" 相关软件（不限版本）\nnautilus 刚装好 Ubuntu，我们在文件管理器的右键菜单里面找不到新建文件的选项，这确实很让人匪夷所思。\n实际上，我们只需要在 ~/Templates 新建一个模板就好。\n$ cd ~/Templates $ touch `TXT.txt` $ touch `Markdown.md` 当然这个方案并不完美，就是并没有在新建文件后自动处于重命名状态的功能。\n","permalink":"http://localhost:4449/posts/nautilus-new-file/","summary":"为 nautilus 添加新建选项的菜单并不困难。因为 ~/Templates 就是专门为之服务的。","title":"如何为 nautilus 右键菜单添加新建文件选项"},{"content":" 相关软件版本\nUbuntu 22.04 及以上 nautilus 是 GNOME 桌面环境默认的 GUI 文件管理器。\n本来其实没想到这样一个简单的任务会引起一些麻烦。把我处理这个麻烦的过程记下来吧。\n首先，我们百度搜索这个问题，从一些相当新的帖子获得的解决方案是安装 nautilus-actions。但意外的是，在 Ubuntu 22.04 中，这个包被移除了。\n我们转战谷歌，找到了这篇帖子，告诉我们这个软件因为缺少更新已经被上游的 gnome 存档了。我们也并不想使用已经被废弃的软件，那就去找替代方案吧——我相信不可能没有提供。\n意外发现：gnome 原来用 gitlab 管理项目，有趣。\n翻译者没有兴趣维护这个软件：\u0026ldquo;Sorry, but if there\u0026rsquo;s no contributions for several years, we\u0026rsquo;re not going to keep it active. It wastes the efforts of our translators. Feel free to fork and maintain it somewhere else if you like (it\u0026rsquo;s open source, after all).\u0026rdquo;\n另一篇帖子 指出了两个替代方案：一个是我在以前使用过的 Nautilus Scripts，最终效果是在右键菜单里面显示一个 Scripts 子菜单，里面有我们写好的脚本作为选项。这种方法不够优雅，我们希望显示在主右键菜单里面；另一个是 nautilus-python，出于对 python 的好感我们最终选择这个方案。\n问题又来了，在 Ubuntu 安装 nautilus-python，也没有这个包。经过检查，一篇帖子 指出其在 Ubuntu 源的名称是 python3-nautilus，这可能是因为一些误解产生的问题。\n现在我们学习写 python 代码来实现 nautilus-python 的扩展。参考资源：官方示例、linuxconfig.org 的教程。我们将写好的 python 文件保存到 ~/.local/share/nautilus-python/extensions/ 即可，然后重启 nautilus 即可。\n先看下面的示例，其为 VSCode 打开文件夹和文件提供了右键菜单（使用命令 wget -qO- https://raw.githubusercontent.com/harry-cpp/code-nautilus/master/install.sh | bash 以快速安装，我对代码做了一些简化，原本的源代码请参考相应的 GitHub 仓库）：\nfrom gi.repository import Nautilus, GObject from subprocess import call import os class VSCodeExtension(GObject.GObject, Nautilus.MenuProvider): # python 支持多重继承 def launch_vscode(self, menu, files): # 参数是 self, menu, files，注意不要修改 safepaths = \u0026#39;\u0026#39; args = \u0026#39;\u0026#39; for file in files: filepath = file.get_location().get_path() safepaths += \u0026#39;\u0026#34;\u0026#39; + filepath + \u0026#39;\u0026#34; \u0026#39; if os.path.isdir(filepath) and os.path.exists(filepath): args = \u0026#39;--new-window \u0026#39; call(\u0026#39;code \u0026#39; + args + safepaths + \u0026#39;\u0026amp;\u0026#39;, shell=True) def get_file_items(self, *args): # 右键文件/文件夹时对应的方法 files = args[-1] item = Nautilus.MenuItem( name=\u0026#39;VSCodeOpen\u0026#39;, label=\u0026#39;Open in Code\u0026#39;, tip=\u0026#39;Opens the selected files with VSCode\u0026#39; ) item.connect(\u0026#39;activate\u0026#39;, self.launch_vscode, files) return [item] def get_background_items(self, *args): # 右键空白位置时的方法 file_ = args[-1] item = Nautilus.MenuItem( name=\u0026#39;VSCodeOpenBackground\u0026#39;, label=\u0026#39;Open in Code\u0026#39;, tip=\u0026#39;Opens the current directory in VSCode\u0026#39; ) item.connect(\u0026#39;activate\u0026#39;, self.launch_vscode, [file_]) return [item] 上面的 python 代码足够直观了。get_backgroud_items 和 get_file_items 返回一个菜单数组，而菜单如何创建和与具体的操作方法链接上面的示例已经足够说明。\n","permalink":"http://localhost:4449/posts/nautilus-right-click/","summary":"nautilus 是 GNOME 桌面环境默认的 GUI 文件管理器。本文介绍如何为 nautilus 添加自定义的右键菜单项。","title":"如何为 nautilus 配置右键菜单"},{"content":"","permalink":"http://localhost:4449/tags/","summary":"tags","title":"标签"}]