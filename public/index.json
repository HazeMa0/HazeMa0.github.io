[{"content":"项目地址（配有使用方法）：https://github.com/HazeMa0/fly-hadoop2-workflow\n作为博客，还是整理一下这个过程中的困难吧。\n1 网络问题很烦人 首先，事实是：2024 年，中国大陆的主要高校和云服务商都关闭了 Docker Hub 的镜像源。但是百度仍有大量的帖子在建议更换镜像源以改善对 Docker Hub 的访问。\n我在我的 Windows 环境部署了代理。WSL2 理应继承代理设置。但是神奇的事情发生了：WSL2 我们可以顺利地 docker build，Windows 却不行。\n然后，我们做了以下事情试图让 Dockerfile 的 from 指令正常工作：\n设置 HTTP_PROXY 和 HTTPS_PROXY 环境变量； 注意！\nHTTPS_PROXY 对应的仍然是 http://localhost:1234，而不是 https！我是在发现环境变量使我的 VSCode 无法正常工作时才发现这个问题的；\n配置 Docker Engine 的配置文件： \u0026#34;proxies\u0026#34;: { \u0026#34;default\u0026#34;: { \u0026#34;httpProxy\u0026#34;: \u0026#34;http://127.0.0.1:9870\u0026#34;, \u0026#34;httpsProxy\u0026#34;: \u0026#34;http://127.0.0.1:9870\u0026#34;, \u0026#34;noProxy\u0026#34;: \u0026#34;localhost,127.0.0.1\u0026#34; } } 修改 ~/.docker/config.json（最后又删掉了） 在我没发现我把 HTTPS_PROXY 写成 https://\u0026hellip; 时，这三个修改都不起作用。然后，在一次神秘的 docker pull ... 后，突然就好起来了，我至今也没搞清楚到底是怎么回事。\n我们认识到，ping 命令走的是 ICMP 协议，对测试 http/socks5 的代理没有意义。 2 对 Docker 和 Dev Container 的错误理解 刚开始，我们在使用 Docker 运行和使用 Dev Container 作为开发环境上犹豫和摇摆了很长时间。我问了 AI 下面这一大段文字，可见我当时的烦躁。\n我现在陷入了一些混乱，需要你来拯救我。要写代码，首先要有开发环境。一般来说，这意味着编译器和解释器以及外部库和系统库的版本，还有代码构建工具的版本。这些东西在不同的开发项目中很容易冲突。然后我们运行起来了程序。然后希望交给测试测试。我没有在公司工作过，我不知道测试测试时需不需要源代码，还是只拿最终可执行程序进行测试。如果需要，那他也需要开发环境。然后经过修改，最后交付用户。用户不同软件之间的运行环境也可能冲突，一般来说，运行环境应该是开发环境的一个子集。容器要怎么终结这一系列混乱？\n好了，现在产生了问题。首先开发者要搭建一个叫做开发环境的玩意。把编译器/解释器/代码生成程序/外部库/系统库封装在容器里面是很好，问题是本地运行的IDE怎么和这些容器里面的玩意交互，从而支持语法高亮和其他功能呢？其次，我说了，运行环境往往是开发环境的子集，编译器对运行环境毫无必要。难道容器通过纵容这些冗余来换取分发效率吗？还有，为什么现实中面向普通用户的应用没有一个用docker分发呢？\n产生这些困惑的 Docker 相关问题是：\n以为代码的依赖都在容器里面，不希望手动把依赖拷到物理机恶心自己。虽然我们确实可以在容器里面援引相关的 jar，但更方便的方法是直接在本地通过 Maven 从中心仓库部署合适的依赖用于测试。 不了解容器挂载技术，以为我们必须手动把 jar 文件拷贝到容器测试。 不了解本地测试 Hadoop，以为所有类型的测试必须使用 hadoop jar 命令执行。实际上我们甚至可以不启动容器进行本地测试，完全本地开发。 区分不了镜像和容器。镜像是死的初始化状态，容器是基于镜像的可工作的实体。Dockerfile 产生镜像。 过早把自己摆到用户角度，认为开发环境对运行环境是冗余的（冗余了你改改 Dockerfile 不就行了吗，对刚开始的我来说改这玩意很困难，现在完全不是了） Dev Container 相关问题是：\n神圣化 Dev Container，以为其不会往容器里面部署 IDE 后端，从而产生了一系列矛盾； 以为 Dev Container 不能配置容器开放的端口。同时认识到，不能修改一个已经打开的容器的端口映射，这是为了简化容器运行状态故意为之的设计。 Dev Container 指定 entrypoint 不是在 postCreateCommand，也不是在 Dockerfile，只有通过 runArgs 指定才是正确的。 不知道为什么，让 Dev Container 执行我的脚本时不能正确识别 echo 的 -e 参数，而是将其作为文本打印。最后我们换用了 printf 命令。 一些 linux 知识 Hadoop 环境初始化脚本需要 ssh 连接，就会产生下面这种需要手动确认的麻烦问题： yes：The authenticity of host \u0026#39;localhost (::1)\u0026#39; can\u0026#39;t be established. ECDSA key fingerprint is SHA256:**********.\rAre you sure you want to continue connecting (yes/no)? 我们希望初始化脚本作为 Docker 的 1 号进程，当然不希望这种需要手工确认的东西出现。我们最终使用以下脚本解决：\ntouch ~/.ssh/config printf \u0026#34;Host *\\n\\tStrictHostKeyChecking no\\n\\tUserKnownHostsFile /dev/null\\n\u0026#34; \u0026gt; ~/.ssh/config 该死的 \\r\\n 在 Windows，git 默认会把 \\n 替换成 \\r\\n。这最后导致我的脚本 push 再 clone 后竟然无法运行了。最后一行命令解决问题： git config --global core.autocrlf false 有趣的事实：JDK 1.x == JDK x 2. 该死的讲义问题 讲义给出的一些命令根本是错误的。\n讲义没有细说应该怎么修改 Hadoop 的若干 xml，百度也在画蛇添足。只有官方文档才是可靠的。\n讲义没告诉我 start-all.sh 的正确位置，让我无法正确配置 PATH。\n鸣谢 感谢 DeepSeek 和 ChatGPT 耐心地听我抱怨和提出问题。没有任何一个人类受得了这么多怨气和不满。\n感谢官方的 Hadoop 安装教程。\n感谢 Google。珍爱生命，拒绝百度。\n","permalink":"https://hazema0.github.io/posts/fly-hadoop2-workflow/","summary":"项目地址：https://github.com/HazeMa0/fly-hadoop2-workflow。借助 Docker 和 Dev Container，舒适地开发老旧框架的程序。本文阐述了这个项目中遇到的困难。","title":"fly-hadoop2-workflow：让编写 hadoop 2.7 应用的效率飞起来"},{"content":" 相关软件（不限版本）\nnautilus 刚装好 Ubuntu，我们在文件管理器的右键菜单里面找不到新建文件的选项，这确实很让人匪夷所思。\n实际上，我们只需要在 ~/Templates 新建一个模板就好。\n$ cd ~/Templates $ touch `TXT.txt` $ touch `Markdown.md` 当然这个方案并不完美，就是并没有在新建文件后自动处于重命名状态的功能。\n","permalink":"https://hazema0.github.io/posts/nautilus-new-file/","summary":"为 nautilus 添加新建选项的菜单并不困难。因为 ~/Templates 就是专门为之服务的。","title":"如何为 nautilus 右键菜单添加新建文件选项"},{"content":" 相关软件版本\nUbuntu 22.04 及以上 nautilus 是 GNOME 桌面环境默认的 GUI 文件管理器。\n本来其实没想到这样一个简单的任务会引起一些麻烦。把我处理这个麻烦的过程记下来吧。\n首先，我们百度搜索这个问题，从一些相当新的帖子获得的解决方案是安装 nautilus-actions。但意外的是，在 Ubuntu 22.04 中，这个包被移除了。\n我们转战谷歌，找到了这篇帖子，告诉我们这个软件因为缺少更新已经被上游的 gnome 存档了。我们也并不想使用已经被废弃的软件，那就去找替代方案吧——我相信不可能没有提供。\n意外发现：gnome 原来用 gitlab 管理项目，有趣。\n翻译者没有兴趣维护这个软件：\u0026ldquo;Sorry, but if there\u0026rsquo;s no contributions for several years, we\u0026rsquo;re not going to keep it active. It wastes the efforts of our translators. Feel free to fork and maintain it somewhere else if you like (it\u0026rsquo;s open source, after all).\u0026rdquo;\n另一篇帖子 指出了两个替代方案：一个是我在以前使用过的 Nautilus Scripts，最终效果是在右键菜单里面显示一个 Scripts 子菜单，里面有我们写好的脚本作为选项。这种方法不够优雅，我们希望显示在主右键菜单里面；另一个是 nautilus-python，出于对 python 的好感我们最终选择这个方案。\n问题又来了，在 Ubuntu 安装 nautilus-python，也没有这个包。经过检查，一篇帖子 指出其在 Ubuntu 源的名称是 python3-nautilus，这可能是因为一些误解产生的问题。\n现在我们学习写 python 代码来实现 nautilus-python 的扩展。参考资源：官方示例、linuxconfig.org 的教程。我们将写好的 python 文件保存到 ~/.local/share/nautilus-python/extensions/ 即可，然后重启 nautilus 即可。\n先看下面的示例，其为 VSCode 打开文件夹和文件提供了右键菜单（使用命令 wget -qO- https://raw.githubusercontent.com/harry-cpp/code-nautilus/master/install.sh | bash 以快速安装，我对代码做了一些简化，原本的源代码请参考相应的 GitHub 仓库）：\nfrom gi.repository import Nautilus, GObject from subprocess import call import os class VSCodeExtension(GObject.GObject, Nautilus.MenuProvider): # python 支持多重继承 def launch_vscode(self, menu, files): # 参数是 self, menu, files，注意不要修改 safepaths = \u0026#39;\u0026#39; args = \u0026#39;\u0026#39; for file in files: filepath = file.get_location().get_path() safepaths += \u0026#39;\u0026#34;\u0026#39; + filepath + \u0026#39;\u0026#34; \u0026#39; if os.path.isdir(filepath) and os.path.exists(filepath): args = \u0026#39;--new-window \u0026#39; call(\u0026#39;code \u0026#39; + args + safepaths + \u0026#39;\u0026amp;\u0026#39;, shell=True) def get_file_items(self, *args): # 右键文件/文件夹时对应的方法 files = args[-1] item = Nautilus.MenuItem( name=\u0026#39;VSCodeOpen\u0026#39;, label=\u0026#39;Open in Code\u0026#39;, tip=\u0026#39;Opens the selected files with VSCode\u0026#39; ) item.connect(\u0026#39;activate\u0026#39;, self.launch_vscode, files) return [item] def get_background_items(self, *args): # 右键空白位置时的方法 file_ = args[-1] item = Nautilus.MenuItem( name=\u0026#39;VSCodeOpenBackground\u0026#39;, label=\u0026#39;Open in Code\u0026#39;, tip=\u0026#39;Opens the current directory in VSCode\u0026#39; ) item.connect(\u0026#39;activate\u0026#39;, self.launch_vscode, [file_]) return [item] 上面的 python 代码足够直观了。get_backgroud_items 和 get_file_items 返回一个菜单数组，而菜单如何创建和与具体的操作方法链接上面的示例已经足够说明。\n","permalink":"https://hazema0.github.io/posts/nautilus-right-click/","summary":"nautilus 是 GNOME 桌面环境默认的 GUI 文件管理器。本文介绍如何为 nautilus 添加自定义的右键菜单项。","title":"如何为 nautilus 配置右键菜单"},{"content":"","permalink":"https://hazema0.github.io/tags/","summary":"tags","title":"标签"}]